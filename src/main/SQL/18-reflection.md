**1**

Решения идентичны.

**2**

Решения идентичны.

**3**

Решения идентичны.

**4**

Между моим и эталонным решением есть разница, вызванная использованием различных аргументов в COUNT: * против I.item_id.

COUNT(*) считает все строки, которые проходят через JOIN, независимо от значений в колонках (даже если поле I.item_id имеет значение NULL).

COUNT(I.item_id) считает только те строки, в которых I.item_id != NULL. Это семантически более точный вариант для подсчета только тех записей, где у гнома действительно есть item_id (предметы).

В будущем, если изменится структура таблицы или запроса, эталонный вариант окажется более живучим, поскольку COUNT(I.item_id) исключит записи без предметов, тогда как COUNT(*) включит все строки, в том числе и без item_id.

**5**

Решения идентичны.

**6**

Мое решение по сравнению с эталонным подразумевало нахождения списка профессий, где количество незавершенных задач максимально среди всех остальных профессий, т.е. группируем незавершенные задачи по профессиям, а затем оставляем только те, которые выигрывают по этому показателю.

Также в моем решении incomplete_tasks лучше было бы заменить на incomplete_tasks_count, а COUNT(*) на COUNT(T.task_id).

**7**

В своем решении я ориентировался на комментарий к колонке:
```
| owner_id | INT | Идентификатор гнома-владельца (NULL, если предмет общий) |
```
поэтому учитывал, что если оружие не принадлежит никому (owner_id == NULL), то им владеют все, отсюда разница:

```sql
LEFT JOIN Dwarves D ON I.owner_id = D.dwarf_id OR I.owner_id IS NULL -- потому что предметы без явно указанного владельца принадлежат всем
```

с эталонным запросом.

**8**

В решении я ориентировался на ту же идею, что и в задании 7. Такие гномы нашлись бы только в том случае, если бы не было общих предметов.