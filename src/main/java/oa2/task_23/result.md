Возьмём АТД DynArray из первого курса. Унаследуем от него ImmutableDynArray, который будет представлять собой иммутабельный список. 

Посмотрим на оригинальный метод вставки элемента с его пред- и постусловиями:

```java
// предусловие: переданный индекс неотрицательный и он меньше или равен числу элементов в массиве
// постусловие: в позицию index вставлено новое значение, а все последующие элементы (если таковые есть) сдвинуты
// вперед. Если для сдвига элементов не хватает места, то емкость массива предварительно увеличивается
public void insert(T itm, int index)
```

Как будут они будут выглядеть в потомке?

Интересно, что предусловие будет ослаблено: нас теперь вообще не интересует индекс и число элементов в массиве, так как в иммутабельном варианте нет возможности вставить новый элемент. Мы настолько ослабили предусловие, что можно сказать вообще от него избавились. Постусловие будет ослаблено по той же причине: коллекция не претерпит никаких изменений.

Таким кривым образом UnmodifiableList в Java унаследован от Collection и ломает "базовую логику": теперь нельзя использовать безнаказанно так же работать с UnmodifiableList, как с другими его мутабельными наследниками.

Если бы ImmutableDynArray ввёл дополнительное предусловие для выполнения метода get(int index), например, чтобы коллекция содержала минимум один элемент, это могло бы нарушить общую совместимость с кодом, предназначенным для работы с DynArray, где такое предусловие не предполагается.
