С полиморфным присваиванием все понятно, но пример ковариатного вызова не привел. В моем ответе показан пример, когда в Java ковариантность поддерживается относительно типа результата переопределяемого метода. Давайте все же приведем пример ковариатного вызова.

В эталонном решении есть неточность: ковариантны не только массивы, но и дженерики вида <? extends T>, например, List<? extends Number>. Отразил это в модифицированном эталонном примере: [CovariantFix.java](CovariantFix.java)

Также в интернетах наткнулся на статью, описывающую обход отсутствия declaration site variance в Java, который, однако реализован в Kotlin: http://ekozlov.blogspot.com/2015/07/java-wildcard.html

По мотивам статьи оформил пример ковариантного типа с примером приведения к более общему типу:
[OtherCovariance.java](OtherCovariance.java)