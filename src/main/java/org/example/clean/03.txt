7.1

enableRestDoc - isRestDocEnabled
// имя enableRestDoc больше похоже на метод, чем на переменную

isNotEmpty - hasElements
// иногда has наравне с is может помочь в формировании правильного имени булевой переменной

hasNoElements - isEmpty
// однако has с отрицанием может запутать логику, лучше подойдет классическое isEmpty

isNotMatch - noneMatch
// в данном случае is не добавляет понимания, а в случаях, когда целевым является отсутствие элементов, подпадающим под критерий noneMatch несмотря на отрицание в названии может вписаться органично (аналогично allMatch и anyMatch)

isDisabled - isEnabled
// конструкции с двойным отрицанием !isDisabled тяжелы для понимания

7.2

В своем коде не нашел представителей из стандартного набора типичных имён. Вероятно, где-то я мог до этого применять found (вместо isFound). Нашел пример близкий по идее к processingComplete из кода тестов:
if (includeInvocations) {
  invocations.invoke()
}
Использование is выглядит избыточно, а одного include недостаточно для раскрытия семантики. Еще близким по идее может служить пример containsFeature, когда is мешает читаемости, а дополнительное слово (Feature) дает понимание семантики.

success, ok, error, done не встречались в моих программах, вероятно, потому что там не было конечных автоматов, а в тестах результат работы сразу скармливался в виде assert...(expected, actual).

7.3

При прохождении по индексам месяцев вполне можно использовать вместо i, j или k - month. Т.к. эта переменная несет вполне определенный смысл (порядковый номер месяца, который можно соотнести с месяцем), то ее применение упростит понимание кода.

7.4

Вполне обычной при работе с датами может быть проверка на последний или первый день месяца: isFirstMonthDay и isLastMonthDay. При работе с некоторой коллекцией объектов, каждый из которых обладает некоторой характеристикой и расположены на некотором отрезке времени может быть необходимо найти первый и последний. При работе с sql-запросами распространенной практикой для указания порядка элементов в выборке является применение переменных ascending/descending.

7.5

Если говорить о примерах из языка Kotlin, то часто, если лямбда простая, то используют запись:
...
.filter { it in accounts }
...
откуда достаточно просто уяснить семантику. Однако при использовании более сложных конструкций:
...
advertService.getOffers().find { it.name == motivationType.name }
...
семантика it выглядит уже не так просто и переменная должна быть переименована в offer:
...
advertService.getOffers().find { offer.name == motivationType.name }
...

Если говорить о введении временных переменных для промежуточных вычислений, то обычно IDE подсказывают, где от них можно избавиться. Распространенный пример:
val available programPeriods = maplService.getAvailableProgramPeriods()
return result
который может быть заменен без потери семантики на:
return maplProxyService.getAvailableProgramPeriods()