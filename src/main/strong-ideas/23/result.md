### Пример 1

Для формирования списка офферов клиента мы должны знать список доступных ему офферов (идентификаторы) и условия каждого оффера. Каждому офферу соответствует один набор условий. Условия едины для оффера независимо от клиента, который этот оффер видит. Список таких условий по всем офферам называется справочником. Чтобы не ходить каждый раз за справочником в стороннюю систему, мы его кэшируем. Для того чтобы в момент протухания кэша все потоки, которым нужен справочник, не отправляли параллельные запросы в сторонний сервис, мы сделали кэш непротухающим. Но справочник периодически нужно обновлять. Этим занимается джоба, которая в фоне ходит в сторонний сервис и заменяет справочник на свежий.

Зависит ли мой микросервис от джобы обновления справочника?

**1. Семантика или конкретная вычислительная модель**

1.1. Зависимости сборки

Несмотря на то, что и джоба и микросервис работают с одной (на самом деле не обязательно) моделью данных, их успешные сборки никак не зависят друг от друга, поэтому можем говорить о том, что зависимости сборки нет.

1.2. Зависимости времени выполнения

Если джоба не отработает вовремя, то появляется риск не соблюсти требования бизнеса по поддержанию актуальности используемых данных из справочника. Если джоба будет использовать модель данных, которая отличается от модели данных в микросервисе, то появляется риск невозможности десериализовать справочник.

Исходя из этого, можем говорить о том, что есть зависимость времени выполнения.

1.3. Функциональные требования

Джобу можно безболезненно заменить на другую реализацию.

**2. Ключевые свойства**

Корректность (консистентное состояние офферов) и актуальность ответов, отдаваемых микросервисом, зависит от того, насколько своевременно джоба выполнит операцию обновления справочника на основе данных, полученных от стороннего сервиса


**3. Пространство допустимых изменений**

Изменение модели в джобе должно проводиться согласованно с изменением модели в сервисе -> джоба и сервис должны использовать консистентную модель (не обязательно одну и ту же) модель. Период между запусками джобы в целом может плавать (быть значительно меньше SLA на обновление), так как жестких требований к нему нет, однако свежие данные в кэш должны попадать не позднее оговоренного времени.

Из этих пунктов следует следующая супер-спецификация: обновление джобой данных в кэше должно происходить своевременно таким образом, чтобы точно отразить изменения в справочнике, произошедшие в стороннем сервисе без искажений и без потерь.

### Пример 2

В некоторых наших сервисах мы подключаем Redis в качестве кэша для снижения нагрузки на сторонние сервисы и оптимизации использования ресурсов. У функционального сопровождения есть требование: "Сервис, использующий кэширование, должен успешно работать и запускаться как при работоспособном, так и при неработоспособном кластере Redis."

Зависит ли сервис от Redis?


**1. Семантика или конкретная вычислительная модель**

1.1. Зависимости сборки

В нашем примере кластер кэширования и сервис на этом уровне никак не связаны.

1.2. Зависимости времени выполнения

Нужно различать такие состояния кластера, как: 
* недоступен
* доступен, но не работоспособен
* работоспособен

Если сервис написан корректно, то недоступный или работоспособный кластер Redis не должен никак влиять на бизнес-логику приложения, старт и останов сервиса. Но, как мы понимаем, отклонения от правила в кодовой базе по невнимательности или халатности тоже появляются.

На что может влиять в случае частичной или полной неработоспособности кластер Redis? Трафик, генерируемый приложением к сторонним сервисам может возрасти вплоть до критических, при которых сторонний сервис не будет с ней справляться. Кроме того в таком случае может возрасти время ожидания ответа от сервиса и снизиться пропускная способность.

Исходя из этого, можем говорить о том, что есть зависимость времени выполнения.

1.3. Функциональные требования

Здесь, конечно, стоит обратить внимание на используемые возможности Redis и подключаемых в сервис библиотек. В целом, замена одной технологи, а вместе с тем и библиотек возможна, что уже было проделано ранее -- миграция с Hazelcast на Redis. Сама миграция была проведена по причине излишней прожорливости Hazelcast, работающей на JVM.

Те сервисы, которые не использовали специфичные для Hazelcast возможности, были быстро перенесены на Redis, остальные сервисы мигрировали еще несколько кварталов, так как требовали индивидуального подхода к переписыванию логики. Плюс мы используем самописные библиотеки для работы с Redis и так или иначе будем обрастать кодом с присущей этой технологии спецификой.

Замена видится достаточно дорогостоящим мероприятием, особенно при отсутствии конкурентных альтернатив и все большего проникновения специфики инструмента в кодовую базу.

**2. Ключевые свойства**

Здесь стоит отметить два ключевых свойства, а именно время ответа сервиса (пропускная способность) и объем трафика, генерируемого нашим сервисом к стороннему сервису, которые напрямую зависят от работоспособности кластера. Опять же при ошибках использования кэша может страдать метрики, завязанные на бизнес-логику.

**3. Пространство допустимых изменений**

Redis как внешняя технология подвергается изменениям. От версии к версии могут меняться API, поведение при работоспособности и неработоспособности кластера. Так как при взаимодействии с Redis мы полагаемся на самописные библиотеки, то допустимые изменения Redis исходят из того, насколько адаптирована (или нет) к ним наша библиотека. Вообще говоря, в таком тандеме каждое обновление требует тщательного тестирования поведения и взаимодействия с библиотеками, так как внесенные изменения могут проявиться непредсказуемым образом.

### Пример 3

Зависит ли Java-приложение, написанное c использованием Spring Boot, от системы сбора метрик Prometheus?

**1. Семантика или конкретная вычислительная модель**

1.1. Зависимости сборки

Для интеграции Prometheus с приложением на Spring Boot используется библиотека Micrometer. Micrometer действует для инструментирования кода приложения с последующим предоставлением метрик для различных систем мониторинга, включая Prometheus. Подключения дополнительных модулей Prometheus в приложение не требуется. Таким образом, зависимости сборки нет.

1.2. Зависимости времени выполнения

Если Prometheus недоступен, это не влияет на основную бизнес-логику приложения. Однако может потребоваться механизм буферизации метрик для последующей их отправки (если не хотим их терять). Частые запросы Prometheus к приложению за метриками могут негативно влиять на его производительность и доступность.

1.3. Функциональные требования

Prometheus может быть заменен на другую систему сбора метрик. Замена требует изменений в конфигурации и коде самописных библиотек, связанных с экспортом метрик, но не затронет основную бизнес-логику. У нас, например, сейчас происходит миграция на Victoria Metrics.

**2. Ключевые свойства**

От Prometheus зависит observability сервиса, с которого собираются метрики. Как уже отмечалось, частые запросы Prometheus к приложению за метриками могут негативно влиять на его производительность и доступность.


**3. Пространство допустимых изменений**

Обновления или изменения в API Prometheus требуют соответствующих обновлений в библиотеках или коде приложения, отвечающем за экспорт метрик. Важно чётко разграничивать основную логику приложения и функциональность мониторинга. Любые изменения в системе мониторинга должны быть изолированы от бизнес-логики приложения, чтобы обеспечить его стабильность и независимость работы.

### Пример 4

Чтобы воспользоваться функциональностью связанной с кэшбэком в мобильном приложении клиенту требуется успешно пройти аутентификацию и авторизацию (делее АиА). Периодически на команду, которая занимается кэшбэком, заводят баг, так как клиент не смог воспользоваться функциональность кэшбэка по причине невозможности пройти АиА)

Зависит ли возможность использования функциональности кэшбэка от АиА в мобильном приложении?


**1. Семантика или конкретная вычислительная модель**

1.1. Зависимости сборки

Модули АиА и кэшбэка (и другие) должны быть успешно скомпилированы, чтобы выполнить сборку релиза мобильного приложения.


1.2. Зависимости времени выполнения

Для того чтобы перейти в раздел кэшбэка, действительно, нужно пройти АиА. В приложении предусмотрены различные уровни авторизации, которые предусматривают доступ к различным видам кэшбэка. 

1.3. Функциональные требования

Эти модули взаимозаменяемы и имеют минимальное количество пересечений (меньше либо равно) по сравнению со связкой АиА и любого другого модуля.

**2. Ключевые свойства**

Конечно, надо упомянуть такую характеристику, как доступность, так как клиент, не прошедший АиА, не увидит раздел кэшбэка. Неудобные или нестабильные АиА также могут повлиять на частоту использования функциональности кэшбэка. 

Гибкость системы авторизации позволяет задать большее число состояний клиента, в зависимости от которых можно предоставить различные условия кэшбэка. Гибкость можно рассматривать и с точки зрения безопасности: нам нельзя дать "лишние" привилегии.


**3. Пространство допустимых изменений**

Система должна быть спроектирована таким образом, чтобы изменения в механизмах авторизации (например, переход на более надежные алгоритмы шифрования, добавление двухфакторной аутентификации) могли быть внедрены без переработки основной функциональности кэшбэка. Набор уровней авторизации может быть изменен, к чему нужно будет адаптироваться.

### Вывод

Из моего опыта управлению зависимостями уделяется недостаточно много внимания на фоне той важности, которую под собой скрывает эта тема. Не в последнюю очередь это происходит потому, что у разработчиков нет представления о правилах препарирования каждой зависимости в частности и рассмотрения всего набора зависимостей системы целиком.

Почему все не так просто? Нельзя не упомянуть многоаспектность зависимостей. При анализе на зависимости надо смотреть с разных точек зрения и понимать, в каком контексте идет о них речь в данный конкретный момент. Важно понимать, что зависимости не ограничиваются прямыми связями между компонентами системы, но также включают косвенные взаимодействия.

Своевременный анализ ключевых свойств системы, зависящих от определенных компонентов или взаимодействий, позволяет выявить имеющиеся критические точки и определить, какие аспекты требуют особого внимания при разработке и тестировании.

Здесь вспоминается, как большая часть логики на одном из проектов была написана в БД от Oracle. Необходимость миграции куда-либо с нее оказалась практически невыполнимой задачей в условиях постоянного роста проекта и невозможности остановки развития продукта. 

Понимание пространства допустимых изменений и способов управления ими критически важно для обеспечения гибкости и адаптивности системы к изменениям без необходимости глобальной переработки или существенных изменений в архитектуре. Кажется, что пространство допустимых изменений тем больше, чем лучше разделена ответственность между отдельными компонентами. 

Здесь сразу приходит на ум EDA как способ построения микросервисной системы.



