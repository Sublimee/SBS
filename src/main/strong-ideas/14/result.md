Сразу стоит упомянуть особенность разрабатываемых мной приложений: мы пишем микросервисы с большим числом интеграций, но при этом не так много бизнес-логики и алгоритмов. Это, определенно, накладывает отпечаток на применение мной TDD.

Я долго думал, на что же больше похож мой стиль TDD -- на парадигму разработки/дизайна или на продуктивную технику тестирования? Кажется, что я тяготею к симбиозу этих вариантов, но с оговоркой, что дизайн -- это спецификация программной системы.

Предлагаю сначала перейти к кейсам, в которых я преимущественно использую TDD: 

1) **если у меня есть относительно объемная задача, например, спроектировать новый эндпоинт**

    В этом случае я использую сквозные тесты, которые описывают возможные бизнес-кейсы (имя теста == бизнес-кейс). Таким образом я задаю некоторую спецификацию системы. По мере продвижения каждого из таких тестов к финальной точке (тест стал зеленым и бизнес-кейс проработан) наращивается число модулей проекта и их объем. Однако я не могу сказать что TDD таким образом имеет влияние на дизайн системы. Кажется, это происходит потому, что у сквозного теста в принципе не очень много шансов на него повлиять. У меня скорее есть некоторый ориентир, к которому я постепенно продвигаюсь, заранее держа в голове желаемую картинку сервисов и их методов. Если эта картинка в результате получилась не очень радужной, то я применяю рефакторинг, который не должен повлиять на результаты моих тестов и уже не связан с TDD.

    Если какая-то логика и соответствующие тесты не были проработаны в начале, то они добавляются в процессе. Дополнительные юнит-тесты я добавляю уже постфактум, когда прошли все сквозные сценарии. Эти юнит-тесты никак не относятся к TDD, а лишь добивают нужное покрытие. Обычно таким образом покрывается некритичная для пользовательских сценариев логика (не влияет на формальную корректность работа), но нужна для более приятного пользовательского опыта (например, правильные текстовки в нужных местах).

2) **если мне надо написать некоторый более-менее сложный алгоритм**
   
    Что можно привести в качестве примера? Например, алгоритм, который учитывает ОС, версию приложения, платформу и т.д. пришедшего запроса. В этом случае я использую юнит-тесты для последовательной проработки всех ветвлений. Это использование TDD соблюдения уже локальной спецификации (in small), которое опять же не влияет на дизайн системы.

Иногда в крупной задаче можно выделить части, которые подпадают под второй пункт. Тогда после проработки алгоритма я возвращаюсь к глобальной задаче. 

Можно ли говорить о том, что в этих кейсах TDD помогает мне соблюсти требования спецификации? Да. Можно ли говорить о том, что TDD является определяющим для организации локального кода системы? В моем случае это скорее уровень одного класса/метода, но не код всего приложения.

Что в таком случае можно отнести к плюсам моей вариации TTD?

1) Фиксация в тестах спецификации программной системы. Такие тесты могут в последующем использоваться разработчиками для того, чтобы понять возможные сценарии использования и как ведет себя система. Мне не приходилось сталкиваться с ошибками разработки в своих проектах, если в дальнейшем требовалось доработать какую-то функциональность: тесты прекрасно справлялись со своей прямой задачей.

2) Набор тестов формируется заранее. После многодневной разработки очень легко сдаться и не дописать или просто пропустить какой-то сценарий. Но если набор сценариев разработан заранее, то удалить постфактум один из них рука не поднимается.

3) В моем коде извне доступны только те методы, которые отражают интерфейсы классов, а не все подряд. Этого удается достичь благодаря компромиссному использованию TDD. 

Что можно, действительно, отнести к минусам моего подхода?

1) Мои итерации по доработке теста и кода могут быть достаточно крупными, однако сейчас у меня с этим не возникает проблем по уже обговоренной выше причине. Отсюда проистекает второй минус моего подхода.

2) Я не всегда откатываю изменения, если тест не прошел. Вероятно, это происходит потому, что в моем коде не так много сложных алгоритмов и в основном ошибки достаточно просто устранимы (это не логические ошибки, а скорее невнимательность). Однако у меня были и такие случаи, когда я откатывал изменения, если видел, что мысль завела меня не туда и код сильно усложняется.

3) Сквозные тесты очень тяжеловесны и для Spring-приложений требуют поднятия контекста: достичь высоких скоростей разработки и CI не получится. В оправдание хочется сказать, что если аналитик передал правильные требования к задаче, то мне зачастую мне даже не приходится выполнять проверок на интеграционном стенде, так как все сценарии уже покрыты. Исключением является лишь подключение новых интеграций.

3) Если приходится вносить изменения в чужой (малознакомый) код, то времени на погружение в предметную область может не хватать. Особенно остро это может проявляться, если требуется внести одну или несколько небольших доработок, которые по постановке никак не пересекаются с уровнем дизайна. В этом случае я пишу серию юнит-тестов, которая покрывает соответствующие методы. Это пример того, как разработка переходит на уровень кода с уровня спецификации. Кажется, что из приведенных выше слов такая доработка и соответствующий подход к тестированию может принести наибольшие проблемы, так как результат доработки непредсказуем, хотя все тесты при этом могут проходить. К сожалению, бизнесу сложно доказать, что добавление одного ветвления потребует продолжительного погружения в домен. Приходится искать компромиссы между скоростью и качеством.

Подводя итог, можно ли назвать мой подход каноничным? Нет, но он работает и показывает свою эффективность. Мне очень близка идея о том, что дизайн -- это спецификация программной системы. Кажется, что эта идея пронизывает весь мой подход. По моему мнению отношение к дизайну, как к организации кода, приводит к нежелательным последствиям в коде: уровень спецификации уходит на второй план, чтобы угодить требования более низкого ("приземленного") уровня, отсюда появляются все неуместные публичные методы и микрофункции, которые очень удобно тестировать. Я бы выразил такую идею, что TDD должен работать на нас, а не мы на TDD: нет совершенно ничего плохого в том, чтобы слепо не следовать канонам, а модифицировать подход под особенности разрабатываемого приложения.