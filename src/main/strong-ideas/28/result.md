Если взять любой мой микросервис, то он будет построен в соответствии с многослойной архитектурой. Это классические для web-приложения на Spring слои: Controller, Service, Repository. Большинство разработчиков на Spring научились делить приложение на слои, обращаться только к нижележащим слоям (но не всегда непосредственно к одному нижележащему) и узлам того же слоя без создания циклических зависимостей. В борьбе с циклическими зависимостями помогает сам фреймворк, выбрасывая логичное исключение: BeanCurrentlyInCreationException. Однако некоторые интервьюеры все же захотят узнать у вас, как обойти это ограничение (рефакторинг не предлагать :). Такие извращенные способы можно почитать здесь: https://www.baeldung.com/circular-dependencies-in-spring.

Для того чтобы показать слои приложения наглядно, я пошел искать картинку в интернетах. Эта показалась мне достаточно занятной: 

![img.png](img.png)

Картинка взята из статьи, которая рассказывает, в том числе о веб-фреймворках, но предлагаю переложить ее на рассматриваемые MVC-приложения. Для этого попрошу вас:
* мысленно поменять направление всех стрелок
* не обращать внимания на подписи Component
* рассматривать Controller как API сервиса, который предоставляет доступ к некоторому домену, а View — как слой, отвечающий за формирование ответов для фронтов (домен + UI составляющие экрана, на котором будут отображаться данные)

Если картинка настолько неточна, то почему мы взяли ее для рассмотрения? Мне хочется остановиться на объединении пунктиром слоев View и Controller, так как до недавнего времени эти слои у нас в сервисах были сцеплены воедино (в слой Controller). Каким образом это выражалось? В сервисе могли быть перемешаны эндпоинты, которые отвечают за отображение данных и за работу с доменом. И хотя циклических зависимостей здесь нет, но объединение слоев View и Controller привело к тому, что каша получилась не только на уровне этого объединенного слоя, но и на уровне Service, который стал по факту объединением уже известного нам Service и некоторой примеси Service View, которая представляет собой UI надстройку над доменом.

Требовалось выработать новый подход, чтобы наш BFF был поддерживаемым. К какой модели мы пришли (это было буквально неделю назад)?

![img_1.png](img_1.png)

**view-api** — это API, отвечающая за агрегацию доменных данных и вывод необходимой информации на экран клиенту. Требования к view-api предъявляются следующие:

* все ручки view-api доступны только с фронтов, т.е. вызывать их из других API нельзя
* данные для отображения на экране, которые не приходят из core-api, должны прописываться в конфигурации view-api (текст, цвета кнопок, фона и др.)
* из view-api нельзя обращаться напрямую в back-системы

**core-api** — API, отвечающая за получение и обработку доменных данных с возможностью переиспользования. Требования к core-api предъявляются следующие:

* все ручки core-api недоступны с фронтов, т.е. содержат префикс /internal
* core-api ничего не знают про данные для отображения на экране (текст, цвета кнопок и фона), только если не проксируют эти данные с back-системы

## Вывод

Таким образом мы пришли к строгой МУРА не только на уровне одного сервиса, но и на уровне взаимодействия сервисов в кластере.