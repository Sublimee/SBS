# Пример 1

Для отображения пользователям различной функциональности распространена система фича-тоглов. Каждый фича-тогл -- своего рода фильтр функциональности. Мы получаем из хранилища список фича-тоглов и соотносим их с параметрами пришедшего клиента. Далее на основе включенных для клиента фича-тоглов будет строиться интерфейс и бизнес-логика приложения.

Аналогичным образом можно сериализовать в БД фильтры. Далее в процессе работы приложения в зависимости от полученных из БД фильтров мы подстроим поведение под конкретного пользователя налету, т.е. настроим рантайм без модификации исходного кода. В этой схеме мы еще достаточно дешево получаем аудит изменений.

# Пример 2

Еще одно применение вижу в возможности построения Event driven architecture (EDA). Как это будет выглядеть? В Kafka будут сыпаться тройки идентификатор сущности + тип сущности + фильтр/действие (о необходимости типа сущности здесь можно поспорить). Сервисы будут потреблять сообщения того типа, за который они отвечают, и применять к данным или генерировать новые события. Это позволит нам уйти от распределенного монолита к реально независимым друг от друга сервисам.

# Вывод

Дефункционализация предоставляет инструмент для превращения поведения программы в сериализуемые структуры данных за счет внедрения и объединения своего рода идентификаторов для соответствующей логики. С данными же большинство систем могут и умеют работать. В примерах выше мы получили возможность динамической конфигурации и влияния на систему: в первом случае за счет хранимых данных, а во втором -- за счет потока событий.

Можно ли сказать на основе вышесказанного, что дефункционализация способствует поддержанию Low Coupling и High Cohesion? Кажется, что Cohesion в контексте дефункционализации возрастает, поскольку вся логика, связанная с интерпретацией группы фильтров применимых к объектам одного типа концентрируется. Расширение функциональности несколько затрудняется, но логика работы становится более предсказуемой. Coupling наоборот -- уменьшается: модули, которые используют фильтры, больше не зависят от кода, реализующего их поведение. Они работают с декларативными данными, а не с замыканиями или функциями. Это упрощает замену, тестирование и интеграцию таких модулей в распределённой среде.