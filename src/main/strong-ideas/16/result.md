В качестве примера был выбран один большой рефакторинг, который покрыл сразу несколько аспектов задания.

В нашем мобильном приложении есть движок, который умеет на основе принятого со стороны сервиса ответа в формате json 
строить UI. UI состоит из виджетов, которые показаны на экране. Виджет (widget) -- контейнер, который может содержать некоторый 
контент (view). Сервис loyalty-view-api содержит бизнес-логику для формирования контекста, а sdui-builder-api отдает по
соответствующему идентификатору и переданному контексту view.

**Было**

Для каждого виджета на loyalty-view-api была создана отдельная ручка, которую надо было дернуть для получения 
соответствующего view. Как это устроено? Каждой ручке loyalty-view-api внутри соответствовал сервис, в котором был зашит 
один или несколько идентификаторов view для получения соответствующих отображений на sdui-builder-api. Почему могло быть зашито несколько 
идентификаторов? Потому что внешний вид может менять в зависимости от количества отображаемых элементов. Все идентификаторы view, которые использовались в сервисах 
были прописаны в конфигурации. Таким образом в общем случае идентификатор в ручке loyalty-view-api мог не совпадать с 
идентификатором, который передавался в sdui-builder-api.

**Стало**

На скрине показаны прошлый и настоящий варианты работы:

![image](https://github.com/Sublimee/SBS/assets/13710048/3f66d1bd-b0df-4860-8603-c106e2a133b0)

Исправлена ошибка, связанная с неправильным трактованием понятия widget. widget -- это контейнер и содержит отображение
view. loyalty-view-api по ручкам отдает не виджеты, а отображения. Ошибка связана с непониманием домена.

Для получения всех view теперь используется единая точка входа, которая параметризируется идентификатором viewId. Теперь не
нужно придумывать для ручек собственные идентификаторы, так как эти идентификаторы у нас уже есть. Теперь при появлении новых
view, которые должны обрабатываться сервисом, не требуется внедрение новых ручек. Это упрощает ведение документации,
тестирование и сопровождение. 

![image](https://github.com/Sublimee/SBS/assets/13710048/ab452a85-cff3-4c75-8411-f6f872b93cad)

Сервис, который использовался старыми ручками, стал не нужен. В чем была его проблема? Каждый новый view требовал внедрения
новой зависимости, список которых и так был уже слишком длинным.

![image](https://github.com/Sublimee/SBS/assets/13710048/a6aee9f0-ab8d-4843-90c4-e98c31435f9a)

Теперь из контроллера все запросы попадают в новый разводящий сервис. Как он устроен? В него внедрены все сервисы, которые реализуют интерфейс ViewService. Если сервис
с поддержкой переданного в ручку viewId зарегистрирован, то запрос будет обработан, иначе вернем пустой контент (избегаем таким образом ошибок).  

![image](https://github.com/Sublimee/SBS/assets/13710048/ea4cf1e8-4d30-4cd6-8006-d04642cd3af3)

Как выглядит интерфейс:

![image](https://github.com/Sublimee/SBS/assets/13710048/7472904f-04c7-45bc-9707-afa3629e1322)

Мы должны возвращать контент и знать viewId, за который отвечает сервис. Вот как выглядит типичная реализация:

![image](https://github.com/Sublimee/SBS/assets/13710048/2d0c3011-2e4e-44ad-97e5-6ecd50067400)

Как видим, теперь тот же viewId идет на вход сервиса, который взаимодействует с sdui-builder-api:

![image](https://github.com/Sublimee/SBS/assets/13710048/687ac330-61c7-41e8-b2b6-68497efdc0dc)

Теперь нет смысла хранить какие-либо идентификаторы в конфигурации, так как идентификатор viewId используется от входа в сервис
loyalty-view-api до получения view в sdui-builder-api:

![image](https://github.com/Sublimee/SBS/assets/13710048/1c9f9890-a8b9-4877-9c86-dbe158780840)

Как быть если viewId один, а вариантов отображения много? На стороне sdui-builder-api формируем несколько отображений 
с одним и тем же префиксом, в качестве которого выступает viewId. В качестве постфиксов выбираем говорящие идентификаторы и
формируем их с помощью логики на loyalty-view-api. Вот как это выглядит:

![image](https://github.com/Sublimee/SBS/assets/13710048/c610e108-49fc-42af-b028-84bc563bb83c)

Чего мы в итоге добились?

1) Теперь нам не нужно знать много групп идентификаторов, так как всю работу берет на себя viewId, который мы дополняем в случае наличия нескольких 
вариантов отображения. Эти варианты уже будут зафиксированы в документации, но основную работу берет на себя новый интерфейс ручки. В целом снизилась когнитивная нагрузка, потому что теперь не треубуется думать о конвертации идентификатора из одной группы (ручка сервиса) к другой (отображение в sdui-builder-api).

2) Разгрузилась кодовая база, так как добавилась универсальность обработки view. Это получилось опять же благодаря заданию интерфейса.

3) Расширение, тестирование, документирование заметно упростились благодаря схлопыванию однотипных участков кода.

