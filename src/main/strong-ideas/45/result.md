1. Как можно снять/ослабить ограничения ORM-ов?

Краткий ответ: не использовать ORM. Если мы используем технологию, которая создает нам проблемы вместо того, чтобы решать их, нужно задуматься о необходимости такой технологии в проекте. Однако не стоит делить все на черное и белое -- нужно взвесить все плюсы и минусы подходов.

Развернутый ответ:

Приведем ограничения ORM на примере Hibernate.

1. Построение неоптимальных запросов -> снижение производительности.

Здесь и проблема N+1, и виртуальная пагинация, избыточные JOIN-ы, сложные подзапросы (ограничивающие использование существующих индексов), пренебрежение обновлением/вставками батчами.

Решение: корректировка поведения Hibernate с помощью аннотаций или явным указанием использовать (около)нативный SQL-запрос.

2. Отсутствие нативной поддержки сложных запросов и моделей БД (оконные функции, JSONB и т.п.).

Решение: проблема частично решается использованием нативных запросов и мапперов (например, @SqlResultSetMapping), но все равно не обеспечивает полный спектр "услуг" БД.

3. Сложности с отображением Value Objects, ограничение доступа к промежуточной таблице при @ManyToMany и работе с наследованием (@Inheritance) и др.

Решение: в большинстве случаев чуть отходящие от базовых сценарии использования Hibernate приводят к тому, что требуется тонкая настройка ряда аннотаций и применение допущений на уровне модели, чтобы "все заработало". Это также приводит к высокой хрупкости конструкции, когда внесение изменений в модель становится трудоемкой задачей (в т.ч. за счет необходимости миграции схемы).

В итоге получаем ситуацию, когда простые сценарии поддерживаются Hibernate на ура, но при усложнении модели данных сложность может возрастать экспоненциально, заставляя разработчиков изыскивать очередной хак под новые вызовы.

Как в целом можно улучшить модели данных в ваших проектах?

В предыдущем задании уже были перечислены подходы, которые можно применить для оптимизации работы с данными в нашем проекте:
* информационная избыточность для представления данных в удобном для пользователя виде или же просто правильный выбор модели данных в соответствии с решаемой задачей;
* CQRS для локализации только нужных данных для выполнения бизнес-логики;
* денормализация, которая позволяет за счет усложнения локальной модели данных упростить модель данных глобальную за счет своего рода сокращения зависимостей.