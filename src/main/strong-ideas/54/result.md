# Задание 2

Несмотря на очевидность идеи никогда не использовал и, кажется, никогда не видел применение такого подход. Отчасти это связано с достаточно редким использования наследования в проектах, с которыми приходилось работать.

# Задание 3

## Пример 1

В библиотеке поддержки SDUI/BDUI нашел объявление абстрактного класса, отвечающего за контекст, который будет использоваться при компиляции экрана/виджета:

```java
public abstract class AbstractContext {
}
```

Класс, судя по всему, создавался для удобства, чтобы объединить все конкретные реализации в одну иерархию для дальнейшей передачи в методы вида:

```java
... handle(AbstractContext context)
```

Смущает то, что абстрактный класс не содержит ни методов, ни состояния, т.е. используется исключительно как маркер. В этом случае предпочтительнее использовать интерфейс, так как наследование не несет никаких преимуществ.

## Пример 2

Примером правильного применения может служить следующая найденная в коде проектов иерархия:

```java
public class BaseAction {
    ...
}

public class DocumentAction extends BaseAction ...

public class RepeatAction extends BaseAction ...

public class AutoPaymentAction extends BaseAction ...

```

Стоит отметить, что экземпляры BaseAction (базовые действия, которые не требуют дополнительной функциональности, имеющейся в других типах действий) создаются:

```java
private Action getAction(...) {
    return switch (...) {
        case DOCUMENT -> createDocumentAction(...);
        case AUTO_PAYMENT -> createAutoPaymentAction(...);
        case REPEAT -> createRepeatAction(...);
        default -> createBaseAction(...);
    };
}
```

из которых в дальнейшем формируется набор действий (и др.):

```java
StatementWithActions.of(statement, statementActions)
```


По коду прослеживается работа с единообразными объектами, которые удобно организовать в одну иерархию. Если бы нам не нужно было работать с ними единообразно и не нужны были бы экземпляры BaseAction, то очень логично было бы перейти к композиции: в каждый из объемлющих классов мы бы подложили BaseAction.

## Пример 3

Вот еще один некорректный пример наследования:

```java
public class StatementValidator {

    public boolean isValidStatement(StatementDto statementDto) {
        return ...
    }
}

public class MobileOperationLogoHandler extends StatementValidator {
    
    public String getLogo(StatementDto statement) {
        return ...
    }
}
```

Экземпляры StatementValidator не создаются. StatementValidator и OperationLogoHandler не передаются в качестве аргументов, не являются элементами коллекций. Насколько я могу понять автора, наследование здесь направлено на более выразительную группировку функциональности. В некотором роде была попытка соблюдения SRP. Лучше такое наследование заменить композицией:

```java
public class StatementValidator {
    ...
}

public class MobileOperationLogoHandler {

    private final StatementValidator statementValidator;

    ...
}
```


# Вывод

Мы в очередной раз сталкиваемся с проблемой выбора между "extends" и "has-a". Чтобы он был правильным, нужно точно формализовать границы ответственности объектов (в т.ч. как мы с этими объектами будем работать) и соблюсти инварианты.

Как уже отмечалось в статье, наследование хорошо работает в стабильной предметной области, где поведение предсказуемо, а расширения лишь уточняют родительскую сущность и нужен полиморфизм (!). Но в быстро меняющейся бизнес-логике, где требования меняются еженедельно (или, что хуже, ежедневно/ежечасно или вообще до конца непонятны), композиция обеспечивает более низкую связанность и может лучше адаптироваться под изменчивый мир. Мне кажется, что я выполнял переход от композиции к наследованию уже в рамках рефакторинга, когда приложение стабилизировалось и стали понятны все требования и перспективы развития.

Наследование -- гораздо более тяжелая в обслуживании зависимость, нежели композиция. В этом контексте хочется отметить, как много говорится о LSP на собеседованиях и как мало (обычно никак) этот принцип применяется на практике. Как я уже отметил в задании 2, кажется, что никто обычно и не задумывается при реализации наследования проверять, соответствует ли оно LSP. Несмотря на то, что LSP может и не нарушаться, никакого подтверждения этому в виде тестов нет. А может они и не нужны, раз их никто не пишет? Предполагается, что наследование используется не в полный рост, а лишь как "стройная" организация классов. Тут как раз стоит сделать отсылку к тезисам "а нужен ли вам полиформизм?" и "какие классы иерархии будут использоваться для инстанциирования объектов?". В этом смысле композиция оказывается проще и безопаснее, не требуя дополнительных телодвижений от разработчиков. 


