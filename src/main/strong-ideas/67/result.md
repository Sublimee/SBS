# Рабочий проект № 1, Java/Kotlin-микросервисы домена Лояльность, API для клиентов (Android, iOS, сайт)

Назначение: обеспечение работы категорийной механики и витрины партнерских предложений.

1. Хороший код можно (и нужно) понимать модульно.

Исходя из заключений, приведенных в пункте 3, при разборе какого-то метода часто приходится изучать не только код проекта в целом, но и искать зависимые проекты. Это также приводит к тому, что мы можем получить непредвиденные эффекты при внесении таких изменений, так как на код разных сервисов при отсутствии библиотеки сложно поддерживать инварианты. Изменения в таком случае подобны доработке карточного домика.

Пред- и постусловия могут потенциально нарушаться ввиду использования одного и того же типа под разные состояния (например, использование nullable вместо non-nullable).

Оценка: 50%

2. Хороший код позволяет быстро восстановить замысел программиста.

Код проектов написан под влиянием фунционального стиля (функциональные цепочки вызовов, отсутствие мутабельного состояния). За счет этого удается добиться сразу нескольких приятных свойств: код выстраивается в легкие для чтения и тестирования fluent-цепочки.

Тем не менее можно встретить достаточно сложные выражения внутри filter {...} и map {...}, тяжеловесные условия, которые хотелось бы спрятать за методами с благовидными названиями. Есть участки кода, которые хотелось бы скрыть за динамической диспетчеризацией.

Если говорить о коде в проектах на Kotlin, то он местами не очень идиоматичен (не используются все конструкции языка), что сделано в угоду лучшей читаемости (ну или у нас низкая компетенция :) ).

Исходя из описанного можно сказать, что замысел хорошо считывается примерно в половине случаев. Функциональный стиль делает свой неоценимый вклад, однако разработчики не всегда заинтересованы в том, чтобы написанный код легко читался. Кто-то просто не задумывается об этом, а кто-то экономит время на рефакторинге. Разработка часто начинается и заканчивается в тот момент, когда реализована функциональность и проходят тесты. Дополнительного этапа переосмысления кода обычно не происходит, особенно когда вся доработка заключается в подкладывании одного ифчика.

Оценка: 50%

3. Хороший код выражает замысел разработчика в одном месте.

Код проекта не очень хорошо концентрирует логику в одном месте, часто требуя доработок во множестве мест (в некоторых случаях даже в нескольких микросервисах). 

Например, есть несколько платформ (мобильное приложение, сайт), поведение для которых хорошо бы начинать сразу выносить в иерархию классов, которая будет централизованно содержать различия в поедении. Тем не менее даже в таких очевидных моментах мы имеем локальные разветвления кода под каждую платформу на уровне отдельных методов.

Еще пример. При необходимости поменять текстовку для разных платформ, нужно делать правки в конфигурациях разных микросервисов.

Оценка: 10%

4. Хороший код надёжен/робастен (несильные изменения требований подразумевают несильное изменение кода).

Это правило для меня выглядит частично как продолжение предыдущего. В дополнение к этому можно отметить, что используемые модели даных и дизайн API часто бывают противоречивыми, оттого подвержены ошибкам.

Код не насыщен инвариантами. За счет возможности указать свойство nullability у типов, количество ошибок в рантайме значительно снижается, тем не менее interop с Java все равно остается незащищенным. 

Один из свежих примеров. Был спроектирован такой API: ответ от ручки должен возвращать два разных состояния экрана, каждое состояние в отдельном поле в json'е. Такой дизайн предполагает некорректную возможность заполнения обоих полей.

Оценка: 25%

# Рабочий проект № 2, монолитный Java-сервис домена Лояльность, API для платформы юридических лиц (сайт)

1. Хороший код можно (и нужно) понимать модульно.

Методы пишутся слишком длинными и классы в целом можно было бы поделить на более компактные. Код больше похож на поток мысли. Преимущественно императивный стиль изложение также не способствует формированию модульности проекта.

Оценка: 25%

2. Хороший код позволяет быстро восстановить замысел программиста.

В то же время за счет большого размера классов и методов сохранятся и высокая концентрация замысла, но это все еще поток мысли, который вряд ли получится быстро считать.

Оценка: 25%

3. Хороший код выражает замысел разработчика в одном месте.

Этот проект отчасти спасает то, что он -- монолит. Все зависимости по данным и логике не могут никуда утечь). Как уже упоминалось выше, идея разбивки на модули практически не коснулась этого проекта, поэтому поток мысли все же позволяет сохранить замысел в одном месте.

Оценка: 50%

4. Хороший код надёжен/робастен (несильные изменения требований подразумевают несильное изменение кода).

Отсутствие тестов, инвариантов делают код очень хрупким. Его очень сложно менять, так как нет связи кода с дизайном.

Оценка: 5%

# Вывод

Исходные правила органично перетекают из одного в другое, дополняя и усиливая общую композицию. Я попробую на их основе сформировать список прикладных рекомендаций.

1) Любые доработки кода должны предварительно быть обдуманы на уровне дизайна всей системы. 

В таком случае мы держим под контролем зависимости, оцениваем необходимость рефакторинга и можем сохранять поддерживаемость решения.

2) Код при изначальном написании и дальнейших доработках должен пересматриваться с точки зрения читаемости замысла. 

Это нужно, чтобы поддерживать связь уровня дизайна с уровнем кода. Даже если идеально передать замысел не получится, то хотя бы по документации можно будет гораздо быстрее восстановить картину происходящего в коде.

3) Функциональности должны быть сконцентрированы в модули, чтобы проще их обслуживать в единой неразмазанной точке.

Это в целом отражает идею перекладывания дизайна на код. Дизайн не должен быть размазан по системе/проекту, тогда и код при перекладывании будет организован должным образом.

4) Несильные изменения требований должны приводить к несильному изменению кода.

Если это все же не так, то надо подумать еще раз о дизайне системы и выполнить соответствующую доработку незамедлительно, когда возникло новое требование.