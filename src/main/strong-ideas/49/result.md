# Пример 1

У нас есть сервисы которые изначально назывались достаточно общо ввиду узкого домена и неопределенности их развития: loyalty-api, partners-api. Некоторые разработчики при принятии решения о размещении новой функциональностью опираются на неявно выведенное ими правило: _всё вместе_, пытаясь наращивать функциональность уже имеющихся сервисов, например добавляют детскую лояльность в loyalty-api.

Чтобы понять, куда и в каком виде попадет новая фича, сначала нужно проанализировать:
1) все сервисы, которые связаны общим доменом;
2) все сервисы которые выполняют какую-то общую функцию для разных доменов (некоторые сервисные функции).

Вполне вероятно, что вместо простого добавления новой фичи в существующий сервис потребуется значительный рефакторинг системы. Ограничивать _всё вместе_ позволяет валидация решений на уровне техлидов аналитики и разработки. Если сомнительное решение все же пролезло в прод, то на команду заводится техдолг.

# Пример 2

В нашем проекте все поставки в прод раскатывались функциональным сопровождением (ФС). Так как команд много, то не у каждой команды есть свой выделенный сотрудник ФС. Обделенные команды встают со своими поставками, в том числе минорными, в общую очередь. Я участвовал в РГ, в рамках которой мы определяли, какие поставки могут быть задеплоены в прод без помощи ФС. Мы сформировали ряд формальных проверяемых признаков таких поставок, а в CI/CD-платформе команды получили возможность деплоить такие поставки самостоятельно. В результате получилось ограничить _всё_, высвободив ресурсы ФС и сократив TTM для команд.

# Пример 3

В нашем кластере если в задаче речь заходила о периодической обработке данных в MongoDB, то *все*гда подразумевалось использование Kafka. С точки зрения удобства разработчика схема показала себя хорошо, но добавляет несоизмеримую сложность в обслуживание инфраструктуры. Часто Kafka – избыточный механизм, чтобы справляться с небольшими объемами данных. Для того чтобы снизить сложность таких решений, была разработана библиотека, которая позволяет обрабатывать документы только с участием непосредственно приложения и MongoDB (блокировка обрабатываемых документов, процессинг, запись флага "обработан", повторная обработка в случае ошибок). Таким образом мы преодолели ограничение для части случаев, сохранив удобный интерфейс и упростив инфраструктуру решения.

# Пример 4

Мы очень сильно зависим от наших коллег с бэкенда, так как завязаны на множество предоставляемых ими REST-сервисов. Недавно коллеги выдвинули условие, что по _всем_ сервисам перестанут поддерживать актуальность тестовых данных в тестовом контуре из-за нехватки ресурсов. Таким образом какие-то happy-path варианты все еще остаются доступными, но в целом проведение регрессионного и интеграционного тестов становится проблематичным. Сейчас в процессе ряд организационно-технических мероприятий, которые направлены на стабилизацию положения:
1) договорились, что для всех новых фич все же будут предоставлены данные для интеграционного тестирования;
2) для уже выставленных сервисов будет актуализирован Swagger, а в документацию добавлены возможные бизнес-варианты ответов;
3) на нашей стороне на wiremock-сервере будем фиксировать примеры ответов из п.2 для проведения регрессионного тестирования;
4) для отслеживания изменений в предоставляемых контрактах применим контрактное тестирование, которое будет заключаться в подтягивании контракта из Swagger и прогоне тестов при сборке приложения на предмет несовместимости наших клиентов.

Таким образом мы, конечно, не сможем избавиться от _всех_ новых появившихся ограничений, потому что ничто не заменит интеграционное тестирование на реальных данных, но сможем значительно снизить риски, которые возникают из-за ухудшения нашего положения.

# Пример 5

В разных кластерах в зависимости от знаний и опыта функционального сопровождения и архитекторов мы раньше выбирали либо _все_ хранить в PostgreSQL, либо –- в MongoDB. В последнее время в нескольких кластерах мы аргументированно доказывали, что решаемая задача требует привнесения нового инструмента. Конечно, в крупных компаниях с достаточно консервативными процессами и стеком этого обычно мало. На руку сыграло повсеместное проникновение этих технологий в других кластерах. Конечно, нужно взвешивать все за и против, чтобы не страдать каждый день от сопровождения выбранного решения в проде и на тестовом стенде, получив удобный API. В нашем случае, когда компетенция может быть довольно просто пошарена между коллегами из разных подразделений, такой отказ от хранения _всех_ данных только в одной БД оправдан.

# Вывод

В целом концепция _все_ / _всё_ может быть как отличной идеей, так и сулить большие проблемы.

Если рассматривать _все_ / _всё_ в контексте стандартизации, то это отличная идея. Единообразие решений часто упрощает их сопровождение.

Пример с fork вроде бы говорит нам о той же стандартизации, единообразии ("в этих двух процессах всё одинаково"), однако мы попадаем в ситуацию, которую хорошо описывает фраза "всех под одну гребёнку". В жизни она подразумевает, что всех участников какого-либо процесса или группы рассматривают как одинаковых, игнорируя их индивидуальные особенности, заслуги, ошибки или контекст. Применительно к разработке можно интерпретировать ее как то, что мы закрываем возможность выбирать решение гибко, навязывая ограниченные рамки (в том числе "так сложилось исторически", "так принято"). Это приводят к появлению ряда краевых условий, которые требуют соответствующие приляпки.

Существует еще такая фраза "если все — значит никто", которую можно рассмотреть с точки зрения организации процессов в IT. Она может по-разному интерпретироваться в разных контекстах, но чаще всего её смысл связан с идеей ответственности, лидерства или значимости. Если за что-то отвечают _все_, то на практике это часто означает, что никто конкретно не берёт на себя ответственность, ответственность размывается.

_все_ / _всё_ — слишком мощная концепция, с которой трудно справиться, так как всегда есть пространство для появления исключений, поэтому лучше изначально ее избегать.