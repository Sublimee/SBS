Специфика разрабатываемых в нашем кластере приложений такова, что они выступают в роли proxy между банковским бэкендом и пользователями и не обременены алгоритмической логикой. Это само по себе способствует меньшему количеству состояний в коде, так как часто нужно просто пробросить какие-то данные по запросу наружу.

Мне даже удалось найти по настоящему МИКРОсервис, который полностью состоит из Service'ов (всего 7 штук) с методами из цепочек вида:

```java
@Service
@Slf4j
@RequiredArgsConstructor
public class PartnerOfficeService {

    private final UwsPartnerOfficeMaplServiceClient officeMaplServiceClient;

    Mono<PartnerOfficeData> getPartnerOfficeData(Headers headers, String partnerId) {
        return officeMaplServiceClient.getOfficeId(
                        headers.getChannelId(),
                        headers.getUserId(),
                        partnerId)
                .onErrorResume(error -> {
                    if (error instanceof UWSException
                            && ((UWSException) error).getHttpCode()
                            .filter(status -> status == HttpStatus.NOT_FOUND.value()).isPresent()) {
                        return officeMaplServiceClient.createOffice(
                                headers.getChannelId(),
                                headers.getUserId(),
                                partnerId);
                    } else {
                        log.error("Fail fetch id of partner office userId: {}, partnerId: {}",
                                headers.getUserId(), partnerId, error);
                        return Mono.error(BusinessException.of(PARTNER_OFFICE_FETCH_FAILED));
                    }
                })
                .flatMap(officeId -> officeMaplServiceClient.getOfficeData(headers.getChannelId(), officeId.getId()))
                .onErrorMap(error -> {
                    log.error("Fail fetch detail of partner office userId: {}, partnerId: {}",
                            headers.getUserId(), partnerId, error);
                    return BusinessException.of(PARTNER_OFFICE_FETCH_FAILED);
                });
    }
}
```

Мне просто повезло в поиске или для этого были какие-то предпосылки? Самое главное:
* код в императивном стиле способствует использованию переменных;
* код в реактивном/функциональном стиле наоборот всячески препятствует введению явного состояния.

Просто использование определенного стиля мало, еще обязательно нужен удобный API, который будет выразителен при решении задач. WebFlux/Reactor удовлетворяют этому требованию. 

Но даже в этом случае работа с состояниями в сервисе присутствует. В каком виде? В неявном:
* логирование (MDC);
* конфигурация (application.yml).

Если говорить о логировании, то обычно в Spring-приложениях используется slf4j, который хранит контекст запроса в MDC (ThreadLocal). Как раз недавно решал проблему, когда в реактивном приложении неправильно работали с контекстом, что приводило к некорректным записям в логе. От MDC можно избавиться путем явной передачи контекста в дополнительном аргументе каждого метода. Чтобы не пришлось писать много bolerplate-кода, можно было бы по примеру Continuation из Kotlin добавлять этот аргумент на этапе компиляции. 

Конфигурацию сервиса можем перенести в хранилище, что, конечно, может значительно увеличить накладные расходы, если она будет запрашиваться часто. Этот подход обычно применяют частично, чтобы иметь возможность динамически менять поведение сервиса. Чтобы сократить накладные расходы, используют кэш в сочетании с подходом near-cache. near-cache может значительно увеличить производительность и сэкономить ресурсы, но это введение состояние, с которым нужно считаться, особенно в МСА, где инстансов приложения может быть больше одного.

Бины также могут быть переносчиками состояния. В нашем случае таких не нашлось. Наличие в бине состояния также может приводить к потоконебезопасности приложения.

Что мы получим после проведения этих манипуляций?

1. Детерминизм -> простота тестирования и отладки
Приложение перестаёт вести себя как чёрный ящик: все его действия зависят только от входных данных и внешнего состояния подобно тому, как ведет себя функциональная цепочка. Такое приложение просто тестировать.

2. Масштабируемость и отказоустойчивость
Stateless-инстансы можно легко горизонтально масштабировать, отпадает необходимость в sticky-сессиях и синхронизации кэша. Если наоборот один инстанс упал — новый продолжает работу без потери данных с прихраненного ранее chackpoint'а.

Чем мы жертвуем?

1. Потеря производительности из-за обращения к внешним системам
Вместо обращения к RAM придётся сделать сетевой вызов.

2. Усложнение управления жизненным циклом
У нас в кластере есть пример в тему. Это многошаг. Многошаг -- череда связанных экранов мобильного приложения, которая поддерживает некоторый процесс (например оплату штрафа). Контент экрана, текущий и следующий шаги, заполненная пользователем информация хранятся в БД. Недавно коллеги даже стартер для его более органичной поддержки в коде написали, чтобы не страдать от boilerplate-кода.

Подробнее можно прочитать здесь https://habr.com/ru/companies/alfa/articles/752068/.

3. Снижение выразительности за счет boilerplate-кода (по мотивам 2)

4. Зависимость от инфраструктуры
Требуются квалифицированная команда сопровождения и разработки и надежная инфраструктура, чтобы задачи оставались прогнозируемыми по срокам выполнения.

Таким образом, если сервис содержит состояние, он становится уязвимым по всем фронтам, так как сам содержит очень тяжёлую зависимость.
Если он делегирует состояние наружу — он становится простым, переносимым, отказоустойчивым, предсказуемым, но нуждается в продвинутой инфраструктуре, которая и возьмет эту зависимость на себя.