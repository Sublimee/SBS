### 2.1

Для получения списка программ повышенного кэшбэка использовался соответствующий сервис бэкенда. Сначала сервис отсылал программы в нужном нам порядке: по возрастанию идентификатора типа программы и по убыванию даты действия программы. В какой-то момент сервис бэкенда начал отсылать данные в ином порядке, в связи с чем product owner предъявил мне претензию. На что я указал на пробел в постановке задачи: требование к сортировке не предъявлялось ни к нашей реализации ни к сервису бэкенда.

### 2.2

Для получения FAQ по бонусному счету я использовал API соседнего сервиса. Получение FAQ с мобильного устройства работало корректно, а с браузера в десктопе -- нет. Оказалось, что для разных платформ контент для FAQ приходит в разных полях. 

Это была совокупность двух ошибок:
1) мне нужно было лучше изучить документацию и реализацию сервиса
2) ошибка проектирования API привела к тому, что увидев необходимое мне поле (использующееся для мобильных устройств), я остановил дальнейшее изучение документации и кода сервиса

### 2.3

Для того чтобы управлять контентом, отображаемым пользователю без релиза мобильного приложения мы используем технология SDUI/BDUI.

При обращении к сервису формирования контента экрана приходил ответ, который некорректно отображался на мобильном устройстве. После анализа контракта Android-разработчиком выяснилось, что в одном из полей есть опечатка.

Так как сервис ранее не использовался, то полноценно протестировать его не представлялось возможным до появления первых потребителей (наша команда). Нам пришлось внести изменения в сервис, чтобы мобильные устройства могли обработать контракт.

Причиной скорее всего стала ошибка аналитики (неправильно зафиксировали контракт) или невнимательность разработчика сервиса формирования контента, который неправильно поддержал контракт.

### 3.1

Пользователь может получать кэшбэк в выбранных категориях. Каждый месяц пользователю на выбор предоставляются свои категории. Для того чтобы подтвердить категории за определенный месяц, ему нужно отправить запрос вида:

```kotlin
data class CategoriesConfirmationRequest(
    val offerDate: String,
    ...
)
```

Что сейчас представляет собой offerDate? Это дата, которая записывается в следующем виде "dd.mm.yyyy". Из типа String это неочевидно. Даже если мы знаем месяц и год, то какую дату проставить? По договоренности с коллегами с бэкенда это любое число месяца. Тоже неочевидно.

Лучшим вариантом выглядит использование такого варианта из стандартной библиотеки Java для однозначного трактования даты:

```kotlin
data class CategoriesConfirmationRequest(
    val offerDate: java.time.YearMonth,
    ...
)
```

или аналогичный самописный облегченный вариант. Переход к дате вида "dd.mm.yyyy" происходил бы непосредственно при вызове сервиса бэкенда (требует единственного комментария на весь проект).

### 3.2

Иногда тип List<T> поля/переменной может быть безболезненно заменен на Set<T>. Что это дает? Тип Set<T> показывает, что все элементы будут уникальными, что говорит об избыточности этапа удаления дубликатов.

Рассмотрим следующую часть предыдущего примера:

```kotlin
data class CategoriesConfirmationRequest(
    ...
    val categoriesIds: List<Int>,
)
```

В данном списке категорий, который прислал пользователь могут находить дубликаты (ошибка логики на стороне фронта). Сейчас, чтобы проверить, что количество выбранных категорий соответствует ожидаемому, необходимо сделать дедупликацию списка. Об этом можно легко забыть.

Такой вариант позволяет работать с уже предобработанным списком категорий:

```kotlin
data class CategoriesConfirmationRequest(
    ...
    val categoriesIds: Set<Int>,
)
```

### 3.3

У нас в коде есть такой метод:

```kotlin
private suspend fun getPercent(confirmedCategories: List<Category>): String {
    val percentRates = confirmedCategories.map { it.percentRate }
    return "${percentRates.min().toInt()} - ${percentRates.max().toInt()}"
}
```

Что он делает? Возвращает в виде строки диапазон, который показывает минимальный и максимальный проценты кэшбэка в выбранных пользователем категориях. Возвращаемое значение выглядит, во-первых, неочевидным для пользователя за пределами исходного кода метода, а во-вторых, не может быть переиспользовано в других кейсах (когда понадобится только верхний или нижний граница диапазона). Лучше возвращаемое значение метода заменить на собственный класс:

```kotlin
data class Range(
    val low: Int,
    val high: Int,
)
```

## Вывод

Как бы качественно ни был написан выш проект, он часто зависит от интеграций, которые ведут себя не всегда так, как бы нам хотелось. По первому блоку примеров отчетливо видно, что взаимодействие с внешними сервисами или API может приводить к ошибкам. Ошибки могут случаться по самым разным причинам, например, недостаточное погружение в API. 

Этот этап один из самых трудоемких и требует значительных усилий аналитика. Должны быть правильно интерпретированы не только success path, но и варианты ошибок API. Человеческий мозг несовершенен, поэтому неформальная документация (в противовес формальной спецификации) может быть понята неверно. И, к сожалению, даже при тщательной проработке глаз может замылиться и проблема аналитики всплывет на более позднем этапе. Также нередки случаи, когда поведение API идет вразрез с документацией.

Вам также стоит учитывать несогласованные изменения и процесс версионирования, работу механизмов аутентификации, rate limiting, особенности канала взаимодействия (сеть и посредники).

Как мы, как разработчики сервисов, с которыми интегрируются, можем облегчить участь потребителей? Кончено, стараться, чтобы код, где это возможно, был самодокументируемым. Тип String, например, может скрывать за собой что угодно: дата, число, диапазон, и т.д. Чем больше свободы -- тем больше вероятность ошибиться. Приведенные решения показывают, как важно точно выражать намерения через типы данных. С первого взгляда такая незначительная деталь может не только предотвратить потенциальные проблемы совместимости и логические ошибки, но и значительно упростить будущую поддержку и развитие проекта.