Представим, что у нас есть закрытый для изменений класс Card. Мы хотим добавить к нему новое поле "priority" для того, чтобы однократно выполнить вычисление приоритета для отображения в UI и далее в программе переиспользовать его. Создание наследника класса Card для добавления всего лишь одного поля кажется избыточным. Кроме того бизнес-данные будут соседствовать с техническими. В этом случае мы можем использовать паттерн со словарём для расширения класса:

```kotlin
data class Card(val id: String)

object CardPriority {
    private val priorityMap = WeakHashMap<Card, Int>()

    fun Card.setPriority(priority: Int) {
        priorityMap[this] = priority
    }

    fun Card.getPriority(): Int? {
        return priorityMap[this]
    }
}

fun main() {
    val card = Card("id")

    with(CardPriority) {
        card.setPriority(2)
        println("Card ${card.id} is ${card.getPriority()} priority")
    }
}
```

или так

```kotlin
data class Card(val id: String)

object CardPriority {
    val priorityMap = WeakHashMap<Card, Int>()
}

fun Card.setPriority(priority: Int) {
    priorityMap[this] = priority
}

fun Card.getPriority(): Int? {
    return priorityMap[this]
}

fun main() {
    val card = Card("id")

    card.setPriority(2)
    println("Card ${card.id} is ${card.getPriority()} priority")
}
```

## Вывод

У нас получилось два решения, которые очень близки в плане реализации, но обладают громадной разницей во влиянии на модель данных. В первом варианте по аналогии с наследованием (где нам нужно было бы использовать соответствующий класс-потомок), если мы хотим работать с приоритетом, то нам нужно использовать соответствующую конструкцию:

```kotlin
with(CardPriority) { ...
```

Мы таким образом ограничиваем область применения приоритета только теми участками кода, где он действительно необходим. Кажется, что в таком случае глобального усложнения модели данных не происходит, мы лишь даем новые локальные возможности там, где это требуется. Когда может быть выгоднее использовать наследование? Все зависит от локальности внедрения расширения. Если КартаСПриоритетом -- это часть домена, то, безусловно, пользователю будет гораздо удобнее работать с именованной сущностью, чем с extension function, живущими своей жизнью вне иерархии.

Что касается второго варианта, то это он скорее похож на внедрение поля в исходную закрытую модель Card. Это то, от чего мы хотели избавиться по причинам нарушения SRP и избыточного влияния (в случае локальной необходимости применения приоритета) на модель.