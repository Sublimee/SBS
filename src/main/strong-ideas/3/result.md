К сожалению, написать код такого объема (пункт 1) у меня не получилось по двум причинам:
1) последнюю неделю я был в отпуске
2) в последнее время я редко пишу код в таком объеме, так как на данном этапе идет поддержка ранее разработанных продуктов
Я приведу примеры кода и "интеграционных" тестов, которые были написаны мной ранее.

Разработка приведенного кода велась не по TDD, так как тесты были написаны после кода приложения. Если не брать во внимание
пренебрежение концепцией test first, то остальные характерные черты TDD в наличии, а именно:
1) код был написан после согласования "спецификации" (контракта с потребителями API, который зафиксировали в документации);
2) при написании приведенных тестов я абстрагировался от реализации в коде, создавая по тесту на каждый кейс в 
соответствии с зафиксированным контрактом ("спецификацией"). Что имею в виду? Для каждого теста сперва создается файл с 
ожидаемым ответом, а затем я пытаюсь этот ответ получить, добавляя нужные моки.

Мне также было бы проблематично выполнить пункт 3 по той причине, что я изначально стараюсь, чтобы код следовал одному дизайну. Получилось ли у меня? Скорее да, и вот почему:

* я использовал константы с ясными именами
* я пытался дать максимально точные и понятные названия методам и переменным
* пользователь API не может получить незапланированное исключение (например NPE), только запланированные вариации (BusinessException или InternalException) с понятными пользователю API расшифровками

Прокомментирую получившиеся тесты из файла [SummaryControllerTest.kt](src%2Ftest%2Fcontroller%2FSummaryControllerTest.kt). 

Первая часть тестов написана для покрытия кейсов эндпоинта /summary/programs, который предназначен для отображения UI с категорийным кэшбэком.

Тест проверяет кейс, когда пользователю предложены категории за определенный месяц, но он их еще не выбрал:

`must successfully return suggested period categorical cashback summary`

Тест проверяет кейс, когда пользователь уже выбрал категории в определенном месяце:

`must successfully return confirmed period categorical cashback summary`

Ряд тестов, которые проверяют, какой ответ будет отдан пользователю, в случае, когда произошла та или иная ошибка

`must fail while getting suggested categorical cashback summary due to incomplete categories directory`

`must fail while getting categorical cashback summary due to user interface content client error`

`must fail while getting categorical cashback summary due to promoted cashback unavailable`

`must fail while getting categorical cashback summary due to categories directory client error`

Вторая часть тестов написана для покрытия кейсов эндпоинта /summary/categorical-cashback, который предназначен для отображения UI с программами кэшбэка пользователя.

Тест проверяет кейс, когда пользователь еще не сделал выбор в предложенных за период программах:

`must successfully return suggested programs summary`

Тест проверяет кейс, когда пользователь уже сделал выбор в предложенных за период программах:

`must successfully return confirmed programs summary`

Ряд тестов, которые проверяют, какой ответ будет отдан пользователю, в случае, когда произошла та или иная ошибка:

`must successfully return empty programs response due to feature-toggle-api error`

`must fail while getting programs summary due to promoted cashback unavailable`

`must fail while getting programs summary due to widget settings service error`

`must fail while getting programs summary due to cards-api error`

`must fail while getting programs summary due to category directory service error`

Наличие таких "интеграционных" тестов, которые проверяют кейсы по "спецификации" решает несколько проблем:
1) возможность безбоязненно модифицировать (удалять/добавлять/править) код, т.к. каждый результаты выполнения тестов дадут понимание, 
изменилось ли поведение приложения по отношению к "спецификации";
2) возможность в более сжатые сроки разобраться в программе на всех уровнях, начиная со "спецификации" (тесты документируют код), продолжая кодом и заканчивая исполнением (именно в таком порядке);
3) сгенерированные по результатам прохождения тестов сниппеты попадают в документацию сервиса. В чем их преимущество по отношению к написанным вручную? Код тестов компилируется, что позволяет уменьшить число ошибок в собираемой документации.

Но все не так просто:
1) от разработчика требуется высокая ответственность и погруженность для поддержания всех кейсов по "спецификации": требуется не только писать новые тесты, но и поддерживать актуальность старых и, в случае ненадобности, удалять их (что тоже очень важно);
2) большое количество таких достаточно однотипных тестов могут ломаться одновременно (пачками) в связи с модификациями кода,
так как в них могут совпадать большие куски "спецификации";
3) такие тесты долго выполняются, так как обычно (с учетом нашей специфики) затрагивают длинные цепочки вызовов.