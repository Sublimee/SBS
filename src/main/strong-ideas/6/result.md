В качестве примеров выли выбраны задачи с собеседований в Яндекс.

## Пример 1

### Условие

Найдите самую длинную строго возрастающую или строго убывающую последовательность чисел в массиве (в ответе требуется вернуть 2 индекса -- границы диапазона). Гарантируется, что хотя бы одна такая последовательность есть. Если последовательностей несколько, то требуется в качестве результата вернуть первую из них.

### Решение

В голове сложилась картина, что надо:
1) при обработке очередного элемента сравнивать его с предыдущим, тем самым понимать, нужно ли начинать обработку новой последовательности
2) запоминать индексы подпоследовательности, которая длиннее предыдущей

С этой идеей я сперва решил в лоб написать алгоритм, который бы решал задачу целиком. Код получился развесистым и я так и не довел его до конца. Код был удален.

Следующим этапом я пошел по пути написания последовательности тестов, где каждый следующий тест немного усложнял входные данные. Итак, как выглядели этапа работы по написанию алгоритма (шаги можно отследить по коммитам файлов [Example.java](..%2F..%2Fjava%2Fstrong%2Fideas%2Flesson_6%2Ftask_1%2FExample.java) и [ExampleTest.java](..%2F..%2F..%2Ftest%2Fjava%2Fstrong%2Fideas%2Flesson_6%2Ftask_1%2FExampleTest.java)).

1. Пишем тест с простым условием Assertions.assertNull(processArray(example)). Так как мы еще не написали логику работы метода, то в простейшем варианте его результатом будет null для всех входных значений. Задаем классы, создаем искомый метод. Проверяем, что код компилируется и тест завершается успешно.

2. Теперь нужно модифицировать тест, чтобы этот он выдал осмысленный результат для простейшего массива из двух элементов со строго возрастающей последовательностью [1, 2]. Задаем переменные для работы алгоритма. Определяем направление текущей подпоследовательности currentDirection (2 сравниваем с 1) и так как она меняется (currentDirection отличается от subSequenceDirection), то начинаем подсчет длины новой последовательности. Так как массив состоит всего из 2-х элементов, то работа алгоритма завершается. Тест проходит успешно, переходим к следующему.

3. Очередной тест должен показать, что метод умеет обрабатывать строго возрастающую последовательность из большего числа элементов, например [1, 2, 3]. Вносим правки в код предыдущего шага и добавляем логику обработки нового состояния. Тест проходит успешно, переходим к следующему.

4. Очередной тест должен показать, что метод умеет обрабатывать строго возрастающую последовательность, которая может быть обрамлена значениями, не входящими в другие последовательности, например [1, 1, 2, 3, 3]. На этом шаге добавлена обработка элементов, которые не составляют строго возрастающие или убывающие последовательности (например, 3 и 3).

5. Очередной тест должен показать, что метод умеет обрабатывать простейшую строго убывающую последовательность из двух элементов, например [2, 1]. На этом шаге были внесены последние правки в код: добавлена обработка убывающих последовательностей.

6. Очередной тест должен показать, что метод умеет обрабатывать строго убывающую последовательность из большего числа элементов, например [3, 2, 1].

7. Очередной тест должен показать, что метод умеет обрабатывать строго убывающую последовательность, которая может быть обрамлена значениями, не входящими в другие последовательности, например [3, 3, 2, 1, 1].

8. Очередной тест должен показать, что метод умеет обрабатывать несколько строго возрастающих последовательностей и в качестве результата отдавать первую из наиболее длинных, например [1, 1, 2, 3, 3, 7, 7, 8, 9, 9].

9. Очередной тест должен показать, что метод умеет обрабатывать несколько строго возрастающих последовательностей и в качестве результата отдавать первую из наиболее длинных, например [9 ,9 ,8 ,7 ,7 ,3 ,3 ,2 ,1 ,1].

Получившийся код оказался простым для написания и для чтения. Я был поражен результатом, поэтому перешел к решению следующей задачи, так как считал, что задача хорошо подходит под итеративный подход (TDD).

## Пример 2

### Условие

Выполните поразрядное сложение неотрицательных чисел, представленных в виде массивов. В качестве результата должен быть массив. При переполнении при суммировании очередного разряда (сумма больше 9) должен быть осуществлен перенос в старший разряд. Результат может содержать лидирующие нули, слагаемые -- нет. Слагаемые содержат хотя бы 1 разряд.

### Решение

В этой задаче мной изначально был выбран неверный подход (видно по коммитам). Идея достаточно простая: складывать одинаковые индексы с конца массива и вычислять перенос. Я же не сразу воспринял идею, потратив несколько первых итераций тестов и кода алгоритма на ошибочное решение. После еще нескольких итераций я выправил ситуацию, но в итоге написание кода было достаточно трудоемким. Что надо было сделать? В момент осознания правильного подхода к решению нужно было стереть код и начать писать его заново, зеленя первый, второй и т.д. тесты. Этапы решения можно посмотреть по коммитам файлов [Example.java](..%2F..%2Fjava%2Fstrong%2Fideas%2Flesson_6%2Ftask_2%2FExample.java) и [ExampleTest.java](..%2F..%2F..%2Ftest%2Fjava%2Fstrong%2Fideas%2Flesson_6%2Ftask_2%2FExampleTest.java).

## Итог

Подход к итеративному усложнению тестов и коду (TDD) прекрасно подошел при решении алгоритмических задач. Постепенное усложнение алгоритма с внесением возможности обработки новых ситуаций позволяют постепенно, маленькими шажками, продвигаться к итоговому решению. Если говорить о решении реальных рабочих задач, то все зависит от специфики сервисов:
* для наших сервисов с большим числом интеграций и простой бизнес-логикой итеративность выглядит несколько избыточной
* если можно выделить в коде более менее сложный алгоритм, то к его написанию точно стоит подходить итеративно

Пока мне не представилось возможности использовать подход в рабочем проекте, так как лучше всего можно прочувствовать его сильные и слабые стороны при написании сервиса с 0.


