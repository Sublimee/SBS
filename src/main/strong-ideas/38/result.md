## Пример 1

Примером использования структурированного журнала событий может служить проект Spring Cloud Config Server с Git в качестве хранилища конфигураций. С его помощью в нашем тестовом контуре реализовано получение конфигурации приложениями. При старте приложение делает сетевой вызов к Config Server за актуальной конфигурацией. Чтобы обновить конфигурацию приложения, нужно обновить соответствующую конфигурацию в Git-репозитории и выполнить повторный деплой. В случае, если необходим откат к предыдущей версии конфигурации -- в репозитории делается revert отдельных коммитов.

## Пример 2

При использовании подхода event sourcing, мы можем предоставлять пользователю разные, в том числе и конфликтующие между собой, версии API. Например, если ранее пользователь оценивал выдаваемый ему кэшбэк по трехбалльной шкале (разные смайлики), то в новой версии API мы можем сконвертировать его прошлые оценки к новому формату, например, 1-5 звездочек.

## Пример 3

Рассмотрим ситуацию, когда мы несколько раз последовательно раскатывали ресурсы k8s с помощью Helm Сhart. Helm зафиксирует каждую из попыток, т.о. у нас появятся несколько версий, которые мы можем использовать для отката. В случае, если мы обновляем версию кластера k8s, история версий полученных с helm может стать частично неактуальной из-за изменившихся версий API в k8s. Как быть? Мы можем заменить (вручную или автоматически) устаревшие манифесты в истории Helm так, чтобы предыдущие версии чартов были пересобраны с новыми манифестами, совместимыми с обновлённым Kubernetes.

# Вывод

Как видим, чем с большим в глубину объемом данных мы можем работать, тем более гибким может быть наше решение. Наверное, из всех примеров стоит выделить подход event sourcing, который вкупе c CQRS позволяет справляться с вновь поступающими вызовами. Имея на руках исторические данные, мы можем вносить коррективы как в уже имеющиеся структуры, так и строить на основе них новые.