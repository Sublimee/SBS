# Рабочий проект № 1, Java/Kotlin-микросервисы домена Лояльность, API для клиентов (Android, iOS, сайт)

Назначение: обеспечение работы категорийной механики и витрины партнерских предложений.

1. Хороший код -- это готовый, "законченный" код

Ряд продуктов этого домена работает в проде. Пользователи с высокой долей вероятности (точный SLI не знаю :) ):

* получают сервис с разумной задержкой, что подтверждается UX-тестами, метриками работы сервисов, VOC (Voice Of Client) даже в случае высоких нагрузок на систему (пуши/рекламные акции/высокий сезон), что обеспечивается постоянными НТ;

* получают сервис с высокой доступностью, что обеспечивается резервированием систем и сервисов, механизмами Circuit Breaker, проведением периодического Chaos-тестирования, канареечным деплоем, раскаткой фич под feature toggle и наблюдением за состоянием системы на проде 24/7;

* получают безопасный сервис, что обеспечивается практиками DevSecOps (IDOR-тестирование, SAST, SCA, Container/IaC Scanning в т.ч. Secrets Scanning и др.), WAF (Web Application Firewall) и другими инструментами.

В целом пользователи видят непротиворечивые данные на разных экранах приложения, связанные с продуктами Лояльности, но бывает и рассинхрон, связанный с техническими и/или административными ошибками. Непротиворечивость и работоспособность одного продукта обеспечивается за счет наличия юнит, интеграционных и end-to-end тестов. Но и здесь ошибки тоже бывают.

2. Хороший код понятен

Новые сервисы преимущественно очень понятны по двум причинам:

    1. они написаны в рамках непротиворечивой и выверенной постановки;
    2. подвергаются тщательному ревью.

Развивающиеся сервисы постепенно теряют понятность по следующим причинам:

    1. возникают новые требования, которые противоречат исходной архитектуре приложения;
    2. нет времени, чтобы устранить противоречия с исходной архитекторой (п. 1), поэтому делает приляпка в виде очередного if;
    3. не подвергаются тщательному ревью, так как разработчики не вникают в контекст текущий доработки в продукт (сервис) в целом.

3. Хороший код эволюционирует

Обновляем библиотеки, версии Java, Spring, Kotlin. Внедряем новые, дорабатываем существующие и заменяем старые spring boot starter'ы. Проводим исследования на предмет необходимости внедрения каких-либо изменений в контексте новых версий технологий и библиотек (например, отказ от Spring WebFlux в пользу Java 25 + Virtual Threads).

Если очередная доработка не укладывается в "быстрый if", то на ревью подсвечиватеся необходимость рефакторинга с целью реализации поддерживаемого решения. Если сроки ограничены и на рефакторинг нет времени, то оформляется продуктовый техдолг.

# Рабочий проект № 2, монолитный Java-сервис домена Лояльность, API для платформы юридических лиц (сайт)

Назначение: наполнение витрины партнерских предложений юридическими лицами (партнерами) и получение всеобъемлющих отчетов и статистики.

1. Хороший код -- это готовый, "законченный" код

Текущий продукт представляет собой переписанное на внутренний стек компании PHP-приложение, доставшееся от аутсорс-компании. Недавно 
продукт попал в прод после полутора лет разработки. 

Пользователи с высокой долей вероятности:

* могут получить сервис с высокой задержкой по причине отсутствия НТ и непроработанности решения с точки зрения высоких нагрузок;

* получают сервис с невысокими показателями доступности по причине отсутствия резервирования систем и сервисов, механизмов Circuit Breaker, отсутствия Chaos-тестирования, канареечного деплоя, feature toggle'ов;

* получают безопасный сервис, что обеспечивается практиками DevSecOps (IDOR-тестирование, SAST, SCA, Container/IaC Scanning в т.ч. Secrets Scanning и др.), WAF (Web Application Firewall) и другими инструментами, что собственно и было целью заведения решения во внутренний контур.

В целом пользователи могут видеть противоречивые данные на разных экранах приложения. Это связано исходно с качеством постановки требований разработчикам, скудной переданной нам документации. Масло в огонь подливает отсутствие должного количества юнит, интеграционных и end-to-end тестов.

2. Хороший код понятен

Единственный монолит имеет множество проблем с точки зрения понятности кода по следующим причинам:

    1. сервис написан в рамках противоречивой и невыверенной постановки при отсутствующем дизайне экранов;
    2. код сервиса не подвергался должному ревью

В условиях постоянно меняющихся неточных требований и сжатых сроков невозможно было хоть сколько нибудь точно продумать архитектуру приложения, чтобы она была поддерживаемой. Вместе с отсутствием ревью код, к которому не предъявлялось никаких требований, несильными разработчиками был написан big ball of mud).

3. Хороший код эволюционирует

Пока целью работ предыдущих этапов было затаскивание проекта в прод. На следующих этапах будет выполнен ряд работ по стаблизации решения:
1) написание всех видов тестов для обеспечения высокого уровня покрытия кода и пользовательских сценариев;
2) закрытие техдолгов, в том числе продуктовых, архитектурных;
3) актуализация документации.

После закрытия этих основных задач код проекта будет готов к тому, чтобы начать эволюционировать.


# Вывод

Все выводы напрашиваются из второго примера. Пререквизитом хорошего кода являются:
1) хорошо написанные в должном объеме тесты (юнит, интеграционные, end-to-end), которые обеспечивают покрытие как кодовой базы, так и пользовательских сценариев;
2) в идеале проведение НТ для каждого релиза;
3) полнота документации.

Плохой код тяжело тестировать. Один из разработчиков недавно пожаловался, что "добивать покрытие до 80% -- слишком душно". Конечно, душно, когда методы по 200 строк :). Это явный сигнал для того, чтобы проводить рефакторинг. Тесты позволяют не бояться менять код, а также уберегают нас от ошибок.

Документация позволяет думать над архитектурой приложения и системы в целом, а также проводить качественное тестирование и ревью. С хорошей документацией гораздо проще выполнить доработку приложения, начиная от постановки задачи, продолжая непосредственно разработкой и хаканчивая тестированием.

НТ позволяет нам находить ошибки, которые проявляются только под нагрузкой. Найденные дефекты производительности могут говорить нам о неправильно выбранных библиотеках, архитекутуре, алгоритмах и т.д., что является обычно хороше пищей для размышления о дальнейших шагах развития проекта.

Когда все эти пререквизиты выполнены, то вместе с интрументами ревью, статического анализа можно безболезненного эксперементировать, перекраивать существующее решение.

Понятное дело, что без должного уровня подготовки все равно может остаться big ball of mud, но у нас хотя бы появятся шансы. Если не говорить о внутренней мотивации становиться лучше (тут еще нужно выбрать правильное направление), в идеале в ИПР каждого сотрудника команды должны быть заложены такие задачи, которые позволят расти в рамках своей компетенции.