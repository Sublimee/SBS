**Примеры 1-2**

В последнее время для меня страховка "от дурака" стала настоящей головной болью. Но не потому, что у нас стало много пользовательского ввода, который надо валидировать. В наших микросервисах много интеграций с сервисами бэкенда (поставляет их нам преимущественно одна команда). Они страдают тем, что обговоренный нами заранее контракт не соблюдается.

Почему это происходит? Один сервис бэкенда используется несколькими потребителями, которые ожидают разный контракт:
1) разные контракты могут отдаваться как в рамках одного большого ответа, содержащего разнородные данные: потребители должны отфильтровать "свои" данные, 
2) так и в рамках нескольких однородных ответов, которые могут быть получены в зависимости от переданных в сервис параметров.

В чем проблема такого подхода? 

1) при наполнении данными такого сервиса сложнее контролировать следование контрактам (например, забыли заполнить обязательное поле)

2) в нашем сервисе при получении большого неоднородного ответа нам приходится отфильтровывать нужные нам данные, при этом задать контракт данных, которые мы принимаем до фильтрации не представляется возможным 

К чему это приводит в нашем коде?

```kotlin
fun getName(): String = name ?: throw InternalException.of(LogicErrorCode.CATEGORIES_DIRECTORY_ITEM_NOT_CORRECT) // приводим к нашему контракту
```

или менее информативное:

```kotlin
.map { terms -> // условия пришли с бэкенда
        CardSection(
            title = terms.defaultCardName!!, // надеемся, что все заполнили корректно
            cardType = terms.defaultCardType,
            imageURL = terms.defaultImageURL!!, // надеемся, что все заполнили корректно
        )
    }
...
```

В случае строгого соблюдения контракта на стороне бэкенда этих двух проверок можно было бы не делать вовсе.

**Пример 3**

Продолжаем поднятую в предыдущих примерах тему. Бэкенд предоставляет нам справочник условий по картам, который содержит десятки тысяч записей (10МБ). Мы берем этот справочник, соотносим с картами пользователя и отображаем на экране дизайны карт (их должно быть не больше, чем самих карт), которые дают ему кэшбэк. Иногда сервис справочника заполняется неправильно (немудрено при таком большом количестве записей), поэтому мы выводим больше/меньше дизайнов, чем должно быть у пользователя. Ситуацию с меньшим числом дизайнов в ответе на нашей стороне никак красиво подправить нельзя, но если число дизайнов больше числа карт, то их количество результате мы ограничиваем по числу карт пользователя.

```kotlin
...
.take(cardsCount)
...
```

Ответ, конечно, все равно остается некорректным, но хотя бы пользователь не видит больше дизайнов, чем у него есть карт. Без такой проверки можно было бы обойтись, если бы на стороне бэкенда справочник заполнялся бы правильно.

**Пример 4**

Иногда в наших сервисах при логировании не пробрасываются некоторые элементы контекста, например идентификатор пользователя. Это происходит по причине зоопарка используемых библиотек, когда обновление одной библиотеки может неожиданным образом повлиять на поведение микросервиса. Для того чтобы гарантировать попадание идентификатора пользователя в лог, он прописывается непосредственно в сообщение об ошибке:

```kotlin
logger.error(e) {
    "Failed getting confirmed offer from MAPL for user with id ${headers.userId} and offer date $offerDate"
}
```

Этого можно избежать двумя путями:

1) написать тесты, которые бы проверяли различные сценарии использования логирования и контекста. Тесты бы выполнялись при сборке каждого микросервиса, что обезопасило бы нас от ошибок в запрограммированных сценариях

2) проверять, попадают ли в контекст, а соответственно и в лог, данные на интеграционном стенде

К сожалению, заранее не всегда получается продумать все сценарии (и новые сценарии периодически всплывают), поэтому мы дополнительно логируем идентификатор пользователя в сообщении. Чем это плохо? Если сообщения об ошибках имеют одинаковый текст, то их проще сгруппировать, чтобы назвать проблему массовой. В нашем случае, когда каждое сообщение обогазено уникальным идентификтором, говорить о такой группировке не приходится, что может отсрочить время обнаружения дефекта.

**Пример 5**

Несколько занятий назад я уже упоминал, что вместо возвращения ошибки в случае, когда у пользователя нет кэшбэка, нужно возвращать соответствующий флаг, на который будет ориентироваться принимающая ответ сторона:

```json
{
    "isPromotedCashbackAvailable": false
}
```

Таким образом мы в принципе исключаем ошибочное состоянии при проектировании системы, что упрощает в дальнейшем и построение логики и логирование ошибок.


**Вывод**

Основная идея защитного программирования заключается в том, чтобы писать программы, устойчивые к ошибкам как со стороны пользователя и смежных систем, так и со стороны разработчика. Почему увлечение идеей повсеместных проверок вредно? Оно приводит к усложнению кода ввиду избыточного и не всегда очевидного контроля за тем, чтобы внутренние состояния программы соответствовали ожиданиям.

Можем ли мы вообще "не защищаться". Нет. От чего избавиться целиком не получится?

1) проверка входных данных, получаемых от пользователя или других "недоверенных" источников, на корректность и допустимость
2) защита от известных уязвимостей, таких как инъекции, переполнение буфера и т.д.
3) ошибки используемых библиотек

Как мы можем уменьшить объем "видимой невооруженным глазом" защиты?

1) фиксировать контракт между сервисами (набор полей, диапазон принимаемых значений и т.п.), использовать схемы на уровне протоколов, чтобы не загромождать лишними проверками бизнес-код
2) выносить часть необходимых проверок на уровень библиотек, чтобы прятать их подальше из кодовой базы приложений
3) пытаться сделать дизайн таким образом, чтобы ошибочных ситуаций, а следовательно, проверок становилось меньше
4) переходить на версии библиотек без уязвимостей или ошибок