# Пример 1

У нас есть несколько стартеров для работы с кэшем: 

* один стартер отвязан от конкретной реализации кодовой базы сервиса и общается с Redis с помощью ByteBuffer;
* остальные стартеры подключаются непосредственно сервисами и адаптированы под корутины / реактивный стек / синхронный стек и оперируют несериализованными объектами.

Назовем первый стартер X, а группу вторых -- Y. Каждый из стартеров Y подключает стартер X.

Кроме базовой функциональности кэширования в X реализована идея near cache, а в Y синхронизация записи по одному ключу несколькими одновременно пришедшими потоками (чтобы не создавать лавинообразную нагрузку при протухании популярного ключа). В какой-то момент обнаружился баг: значение-заглушка, предназначенное для блокировки на запись, по каким-то причинам не инвалидируется, попадает в near cache и там зависает на ttl кэша, оставляя клиента в ожидании реального значения.

Раньше было реализовано так: пришедший поток ставил значение-заглушку по тому же ключу, где будут храниться данные, и уходил получать реальные данные. Для того чтобы исправить эту ошибку, я разделил логику взятия блокировки и хранение данных по разным ключам, чтобы значение-заглушка не могла из Y попасть в X. Мейнтейнер не принял доработку, так как она, очевидно, снижает производительность: требуется больше запросов для работы с двумя ключами вместо одного.

Я сделал другую реализацию: на уровне стартера X добавляю magic bytes для того, чтобы в классах на уровне классов near cache определить заглушку и не класть ее в кэш.

В чем минус этой реализации? Теперь c уровня стартеров Y в near cache не попадут объекты, которые случайным образом тоже начинаются с magic bytes.

# Пример 2

До недавнего времени мы использовали одни и те же классы и в качестве DTO для того, чтобы принять данные от стороннего сервиса X и для написания бизнес-логики. Так как мы являлись не одним потребителем сервиса X, то OpenAPI-контракт, предоставляемый сервисом был гибкий. Это подразумевает, что практически все поля nullable. Конвертации и валидации приходящих от сервиса X данных не происходило в связи с чем в бизнес-логике мы часто получали NPE, так как считали все нужные нам поля non-nullable. 

Периодически возникали ситуации, когда то или иное обязательное поле не приходило. В связи с этим при приёме DTO мы проводи валидацию всех полей, которые должны быть non nullable и фиксируем корректные ошибки.

# Пример 3

Два сервиса используют один библиотечный enum. Каждый его подключает как зависимость. При этом один сервис является потребителем запросов от второго сервиса. Были случаи, когда библиотека дорабатывалась и в enum добавлялись новые значения. Сервис-продюсер подключал новую версию библиотеки и начинал отправлять новые значения из enum. Принимающая сторона со старой версией библиотеки не могла их распарсить и падала с ошибкой.

# Вывод

"Ошибка модульного рассуждения -- ошибка, когда программа работает, но не подчиняется спецификации кода". Получается, что единственная проблема здесь -- неправильная спецификация исследуемого участка кода. Мало написать полную и корректную спецификацию, её нужно поддерживать. Если говорить о фиксации спецификации с использованием natural language, то основная её проблема -- она не компилируется, а значит подвержена риску стать невалидной. Спецификация в идеале должна быть формальной, но это не очень распространённая практика для описания того, что из себя представляет модуль.

В этом смысле OpenAPI -- отличный способ задать контракт сервиса и проверять его на наличие расхождений. Различные аннотации на поля/аргументы/методы также помогают задать более строгие требования в кодовой базе.

Пример 1 иной. В нём дает течь абстракция, поэтому знания о внутренней реализации фичи на верхнем уровне растекается до самых нижних уровней. Эти нижние уровни нужно "защищать" комментариями от разработчиков, которые не будут знать об удивительной особенности нашего дизайна (или от себя через неделю/месяц/год). Плохо то, что легко может быть написан новый код, который вообще не потребует читать какие-то комментарии или Readme.