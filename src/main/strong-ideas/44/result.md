**Пример 1**

Пойдем по стопам изученной статьи и приведем еще один пример, когда можно с пользой повысить информационную избыточность. Сам API для пользователей не упрощается, но значительно повышается эффективность работы с данными. В то же время внедрение этого механизма достаточно просто и не усложняет его логику приложения (хотя, конечно, бездумно их так же, как и материализованные представления применять нельзя). Как наверное, несложно догадаться, речь про индексы. 

Приложение взаимодействует с БД, которая хранит таблицу с заказами по предложениям партнеров. Мы взаимодействуем с этой таблицей при помощи двух запросов:
1) получение заказов пользователя;
2) получение заказов за определенный период в определенном статусе.

Для каждого из этих запросов создан свой индекс. С учетом соотношения числа записей к числу чтений (~ 1 к 9) они позволяют эффективно проводить выборку заказов по описанным выше сценариям.


**Пример 2**

Фичи мобильного приложения закрываются фичатоглами. В каждом фичатогле прописан список пользователей, которым доступна фича. Администратор через UI загружает фичатогл с соответствующим списком пользователей и может его редактировать.

```java
@Data
@Document(collection = UserFeature.FEATURES)
public class Feature {
    
    public static final String FEATURES = "features";

    @Id
    private String feature;
    @Indexed
    private Set<String> users;
    @Indexed
    private Set<String> excludeUsers;
}
```

Так как загрузка фич происходит нечасто, то модель данных хорошо бы адаптировать под более нагруженный сценарий, а именно: пользователь обращается по API за списком доступных ему фич. Как хранить данные в БД, чтобы запросы пользователя обрабатывались быстро и сделать API более удобным? Можно дополнительно хранить каждого пользователя со списком его фич:

```java
@Data
@Document(collection = FeatureUser.USER_FEATURES_COLLECTION)
public class UserFeatures {
    
    public static final String USER_FEATURES_COLLECTION = "userFeatures";

    @Id
    private String user;
    @Indexed
    private Set<String> features = new HashSet<>();
    @Indexed
    private Set<String> excludedFeatures = new HashSet<>();
}
```

Таким образом нам не придется делать перебор всех фич, чтобы в списке пользователей каждой из них найти искомого пользователя. Можно попробовать обновить USER_FEATURES_COLLECTION в рамках одной транзакции с FEATURES, но если будут замечены проблемы с производительностью, то можно перейти на event-driven подход.

**Пример 3**

Применим CQRS и event-driven подход для реализации более удобного API для подсчета выгоды пользователя. 

Мы как middle-слой для нашего мобильного приложения получаем данные о начислениях на бонусные счета с backend'а. Этот список используется и для отображения пользователю списка этих начислений и для подсчета статистики по месяцам. Кажется, что можно было бы каждый раз не высчитывать статистику начислений, а добавить новое хранилище, которое бы реагировало на вновь поступающие начисления.

Это в некотором смысле то же материализованное представление только с оглядкой на способ получения исходных данных.

**Вывод**

Для того чтобы в приложении использовать информационную избыточность, эту избыточность надо в большинстве случаев создать. Как уже говорилось, информационная избыточность требует синхронизации данных, которую часто бывает довольно сложно поддерживать, хотя API при этом может значительно упроститься. Эти два аспекта нужно предварительно хорошенько взвесить на чашах весов прежде чем отдать предпочтение одному из них.

В разработке я предпочитаю двигаться от простоты поддержки решения разработчиком и существования одного источника правды в сторону избыточности с дополнительными расходами на ее поддержание. В моих рабочих проектах первопричиной такого перехода часто становится не неудобный API сам по себе, а то, что нам становится недостаточно имеющихся вычислительных ресурсов для решения поставленной задачи (пример 2).

Информационная избыточность по сравнению с одним источником правды создает плюс 1 зависимость (как минимум), которую приходится учитывать при поддержке разработанного решения. Насколько хорошо команда может управлять зависимости напрямую зависит от ее компетенций. В слабых командах я бы как можно дольше отодвигал момент усложнения проекта.