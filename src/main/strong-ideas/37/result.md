# Задание 1

## Пример 1

При задании конфигурации приложения возможны ошибки. Чтобы не отлавливать их в процессе работы приложения с помощью различных проверок (if, assert), можно проводить валидацию конфигурации при старте приложения:

```kotlin
@field:NotBlank
val registrationId: String

@field:PositiveOrZero
val baseSecondsDelay

@field:NotEmpty
val cardTypes: Set<String>
```

## Пример 2

Введение детских бонусных счетов привело к повсеместному разветвлению логики без введения иерархии наследования: 

```kotlin
if (isKid) {
    kidsBonusAccountsService.getBonusAccounts(headers)
} else {
    bonusAccountsService.getBonusAccounts(headers)
}

...

val widget = if (isKid) {
    unifiedLoyaltyProperties.kidWidget
} else {
    unifiedLoyaltyProperties.widget
}
```

Такое решение плохо масштабируется на новые категории пользователей, потому что часть логики будет дублироваться в независимых имплементациях. Кроме того изменения при появлении новых категорий придется вносить в разрозненные участки кода. Ситуация будет тем хуже, чем больше категорий пользователей будет вводиться.

Что можно сделать? Там, где предполагается разветвление будем выбирать одну из реализаций интерфейса/абстрактного класса:

```kotlin
interface BonusAccountsService {
    fun getBonusAccounts(Headers headers) : BonusAccount
}

class WidgetService(
    val bonusAccountsServiceByRole: Map<Role, BonusAccountsService>
) {
    ...
    bonusAccountsServiceByRole[headers.role].getBonusAccounts(headers)
    ...
}
```

## Пример 3

При разработке бэкенда для очередной версии мобильного приложения часто возникали новые краевые случаи. В связи с чем? Нативная реализация ios и android приложений требовала обратной совместимости контракта. Таким образом появилось много настроек вида:

```kotlin
data class MotivationSectionProperties(
    @field:NotEmpty
    val supportedAppVersionsByOs: Map<OperationSystem, ApplicationVersion>,
    val content: Motivation,
)
```

Далее в коде формирования элемента UI мы обращались к настройкам supportedAppVersionsByOs, чтобы принять решение о том, как будет выполняться алгоритм. Многочисленные такие разветвления по версиям делали код трудно поддерживаемым.

Решение оказалось неординарным и не было сделано непосредственно для решения этой проблемы. Нативные реализации заменили в старых версиях -- webview, который научили работать с SDUI-контрактом, а в новых версиях -- нативным SDUI-движком. Таким образом мы стали поддерживать один и тот же контракт на всех платформах. Остается вопрос: нативный SDUI-движок же тоже подвержен изменениям, но как в таком случае не скатываться в обрастание краевыми случаями? Старые версии приложений мы переводим на webview, а на вновь появившихся предоставляем доработанные нативные SDUI-движки. Таким образом, дорабатывая обе технологии, мы не вводим новые краевые случаи.

## Пример 4

Не могу сказать, что этот пример слишком усложнял программу, однако часто приводил к ошибкам.

В библиотечном классе мы предоставляли такой список месяцев в именительном падеже:

```java
    public static final List<String> MONTHS_CASUS_NOMINATIVUS =
            List.of("январь", "февраль", "март", "апрель", "май", "июнь", "июль",
                    "август", "сентябрь", "октябрь", "ноябрь", "декабрь"
            );
```

Как несложно догадаться, проблемы возникали при реализации выбора месяца на стыке годов. Эту проблему мы решили изменением API:

```java
public static String getCurrentMonthWithCase(@NotNull Month currentMonth, @NotNull MonthCase monthCase) ...

public static String getNextMonthWithCase(@NotNull Month currentMonth, @NotNull MonthCase monthCase) ...
```

Теперь API не дает пользователю ошибаться.

# Задание 2 и Вывод 

В первую очередь нужно разобраться, что для вашего приложения краевой случай, а что обычный use case. Где эта грань? На поддержание каких сценариев вы должны тратить больше сил и средств. В этом смысле может быть выгодно преподносить некоторую "урезанную" функциональность бизнесу, как в случае с классом СтранныйРецепт, в качестве быстрого и простого решения, чтобы не усложнять систему. Конечно, заранее нужно уточнить, насколько популярна будет фича среди пользователей, какие у нее перспективы развития. Иначе придется долго мучиться с костыльным решением, на переработку которого в будущем не выделят время.

Но, как мне кажется, на выбор способа обработки краевого случая также должно влиять потенциальное влияние на кодовую базу. Чем меньше влияние, тем более "костыльным" может быть обработка этого случая. Тут главное -- не заиграться и вовремя применить рефакторинг.

Показательным является пример с детскими бонусными счетами (Пример 2). Пока влияние возраста пользователя сводилось к фильтрации бонусных счетов в одном месте в коде, мы просто формировали соответствующие предикаты для взрослых и для детей. Как только проверка возраста проникла в несколько участков кода и одновременно с этим бизнес сообщил о планах по развитию этого направления, мы решились на вынесение детской логики в отдельные сервисы.