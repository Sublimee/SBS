# Пример 1

```java
// Создать нового пользователя в системе
//
// Предусловия: 
// - создать пользователя может только администратор
// - пользователь с заданным email не существует в системе
// - все обязательные поля заполнены корректными значениями:
//      * email
//      * firstName
//      * lastName
//      * middleName
//      * phone
//      * position
//      * role
public void createUser(CreateUserRequest request) {
    // ...
}
// Постусловия:
//  - новый пользователь создан в системе (БД) с корректно заполненными переданными полями и статусом AWAITING_CONFIRMATION
//  - токен верификации сгенерирован, сохранен и отправлен пользвателю по указанному email
```

Код создания пользователя вызывается только в одном месте из контроллера.

Комментарий:
- проверка роли происходит только в контроллере;
- проверка формата email и других полей не проводится, только обязательность их наличия (в соответствии с OpenAPI спецификацией);
- проверка наличия пользователя с заданным email проводится непосредственно в createUser;
- отправка письма происходит в той же транзакции, что и сохранение пользователя в БД. Существует вероятность, что письмо будет отправлено, но из-за сетевого сбоя мы не получим об этом подтверждения. Таким образом пользователь не будет создан, хотя письмо будет отправлено. Для обеспечения гарантии at least once лучше использовать transactional outbox для фиксации события создания нового пользователя, а отправку письма вынести в отдельный процесс.

# Пример 2

```java
// Создать новый оффер в системе с привязкой к партнёру
//
// Предусловие:
// - создать пользователя может только партнёр
// - партнёр, идентификатор которого передан в запросе, существует в системе
public CreateOfferResponse createOffer(CreateOfferRequest request) {
    // ...
}
// Постусловия:
//  - новый оффер создан в системе (БД) и привязан к переданному партнёру
//  - оффер проинициализирован значениями по умолчанию:
//      * имя -- "Новая акция"
//      * статус -- DRAFT
//      * неактивный
//      * без автопродления
//      * продолжительность -- 45 дней
//  - в ответе возвращается идентификатор созданного оффера
```

Код создания оффера вызывается только в одном месте из контроллера.

Комментарий:
- проверка роли происходит только в контроллере;
- проверка наличия обязательного поля с идентификатором партнёра проводится в соответствии с OpenAPI спецификацией;
- проверка наличия партнёра с заданным идентификатором проводится непосредственно в createOffer.

# Пример 3

```kotlin
// Зафиксировать пользовательский выбор по программе кэшбэка
//
// Предусловие:
// - передана существующая программа кэшбэка
// - переданный список идентификаторов "офферов" непустой
// - заголовки содержат идентификатор существующего пользователя
override suspend fun accept(headers: Headers, acceptRequest: AcceptRequest): ResultScreenInfo? {
    // ...
}
// Постусловия:
// - в системе зафиксирован выбор "офферов" по соответствующей программе
// - очищен кэш состояния программ пользователя
// - зафиксировано событие аудита действия пользователя
// - в ответе возвращается информация для реультирующего экрана
```

Комментарий:
- проверка наличия в заголовках идентификатора пользователя происходит в контроллере;
- проверка существования пользователя не проводится;
- проверка существования программы кэшбэка осуществляется непосредственно в методе;
- проверка переданного списка идентификаторов "офферов" осуществляется непосредственно в методе.

# Пример 4

```kotlin
// Выполнить активацию квеста
//
// Предусловие:
// - переданный идентификатор квеста содержится в списке активных (доступных) на текущий момент квестов
// - заголовки содержат идентификатор существующего пользователя
@CachePutAsync(
    cacheName = ACTIVE_QUESTS_CACHE_NAME, 
    key = USER_ID_CACHE_KEY,
)
suspend fun activateQuest(headers: Headers, questId: String): List<MaplActiveQuest> = {
    // ...
}
// Постусловия:
// - для пользователя в системе выполнена активация квеста
// - в кэше по пользователю зафиксирован актуальный список активных квестов
// - в ответе возвращается актуальный список активных квестов пользователя
```

Комментарий:
- проверка наличия в заголовках идентификатора пользователя происходит в контроллере;
- проверка существования пользователя не проводится;
- проверка существования и доступность для активации квеста осуществляется непосредственно в методе.

# Пример 5

```kotlin
// Выполнить активацию промокода
//
// Предусловие:
// - заголовки содержат идентификатор существующего пользователя
// - переданный идентификатор промокода существует и активен в системе
// - для пользователя включена фича активации промокодов
// - пользователь не превысил число попыток ввода промокода
@CacheEvictAsync(cacheNames = ["active_promocodes"], key = "#headers.userId")
suspend fun createPromocode(
    headers: Headers,
    request: CreatePromocodeRequestDto
) {
    // ...
}
// Постусловия:
// - для пользователя в системе выполнена активация промокода
// - очищен кэш промокодов пользователя
```

Комментарий:
- проверка наличия в заголовках идентификатора пользователя происходит в контроллере;
- - проверка существования пользователя не проводится;
- проверка активности фичи для пользователя проводится непосредственно в методе;
- rate limiting проводится непосредственно в методе;
- проверка существования и доступность для активации промокода осуществляется непосредственно в методе.


# Вывод

Проанализировав все примеры выше можно выделить несколько закономерностей:

1) часть проверок вносится непосредственно в сам метод

Пользователю метода не нужно думать, что под его капотом. Все проверки уже в него зашиты. Это часто хороший вариант избежать зоопарка "оберток" при вызове метода, когда каждый разработчик пишет свой код, чтобы проверить предусловия.

2) часть проверок выполняется при "входе" в приложение

Это, например, проверка удовлетворения входных параметров/заголовков спецификации OpenAPI. Это в некотором роде продолжение идеи из пункта 1, только валидации происходит не в самом методе, а при "входе" запроса в приложение в целом. 

Кажется, что rate limiting тоже должен переехать на этот более высокий уровень. Но тут есть и другая сторона. Чем дальше проверка от непосредственного вызова, тем больше шансов нарушить предусловие. В примерах 1 и 2 проверка роли происходит при входе в контроллер. Это означает, что сам метод может быть вызван откда угодно, где проверки на соответствующие роли может уже и не быть.

3) часть проверок можно не выполнять локально

На этапе работы наших приложений мы доверяем тому, что пришедший идентификатор пользователя существует и корректен. За это отвечают гейтвеи.

Получается, что каждый слой отвечает за проверку своих предусловий, от глобальных к локальным: гейтвей -> спецификация контроллера -> сам метод.

И это в целом происходит не случайно: чем ближе предусловие к домену (тому, что делает операция), тем ближе оно должно проверяться к методу.