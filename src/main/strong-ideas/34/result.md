### Разминочное

### Пример 1

Эндпоинт отдает список программ лояльности пользователя. Каждая программа снабжена флагом, который говорит о том, активирована ли программа пользователем. Эндпоинт используется в двух кейсах: 
1) непосредственно отображение списка программ лояльности с соответствующими баджами (активирована или не активирована) на экране мобильного приложения, куда можно провалиться с главного экрана;
2) отображение на главном экране глобального счетчика возможных действий пользователя, который вычисляется подсчетом неактивированных программ.

Уже на данном этапе понятно, что в кейсе 2 требуется значительно меньше деталей, чем в кейсе 1, однако кейс 2 является более часто запрашиваемым, так как запрос идет с главного экрана приложения. Нужно разделить эти две реализации на: 
1) детальную (но более ресурсоемкую)
2) и краткую (но более производительную)


### Пример 2

Своего рода пример боксинга, но не функции, а типа:

```kotlin
data class ExtendedAmount(
    val amount: AmountDTO,
    val payOutDate: LocalDate? = null,
    val description: String? = null,
    val deeplink: String? = null,
    val title: String? = null,
) : java.io.Serializable
```

Наблюдается попытка поддержать разную функциональность за счет только одного класса. На это намекают практически все nullable-поля. В итоге имеем ситуации, когда в разных местах в коде контракт одного и того же класса требуется свой.

### Пример 3

А вот пример боксинга на уровне функции. На некоторых экранах нужно просто отображать баланс пользователю, а на других -- еще и фиксировать в БД последний увиденный пользователем баланс. На уровне сигнатуры появляется флаг, который активирует запись в БД последнего увиденного баланса. В итоге в Get-запросе получили side-эффект в виде "тяжелого" обращения к БД. Фиксация и получения баланса, конечно, должны быть разнесены.

### Разминочное-2

Проанализировав, свои решения, я понял, что не склонен скатываться в боксинг. Более эффективными являются использование паттерна "Стратегия" или полиморфизма.

### Разминочное-3

В новом для себя коде это могут быть сотни раз в час. Чем более код знаком, тем меньше приходится делать отсылок. Как можно снизить количество таких отсылок?
1) имена классов/методов/переменных имеют понятные имена;
2) в случае необходимости к коду даны комментарии, которые исходят из его дизайна;
3) соблюдаем SRP;
4) исключаем мутабельные состояния (поля классов/переменные/аргументы);
5) избавляемся от nullability, где это возможно для того, чтобы сократить развилки, связанные с разной логикой определения полей/переменных/аргументов.