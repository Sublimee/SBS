Мне за несколько часов поисков не удалось найти в своем коде и коде коллег подходящие примеры. Я просил ChatGPT в режиме глубокого исследования подобрать мне примеры из реальных проектов, но кроеме игрушечных вариантов в ответ ничего не получил (плохо формулировал запрос). Я решил разобраться, в чем причина.

Для начала хотелось бы рассмотреть пример с Employee более подробно. Запишем его в Kotlin:

```kotlin
data class Employee(
    // зададим поля так в целях демонстрации
    val hoursWorked: Int,
    val hourlyRate: Double,
    val yearsOfExperience: Int,
    val projectsCompleted: Int,
)

val calculateSalary: (Employee) -> Double = { employee ->
    employee.hoursWorked * employee.hourlyRate
}

val baseBonus_A1: (Double) -> (Employee) -> Double = { salary ->
    { employee ->
        salary * (0.1 + employee.projectsCompleted / 10)
    }
}

val extraBonus_A2: (Double) -> (Employee) -> Double = { baseSalary ->
    { employee ->
        val extraYears = (employee.yearsOfExperience - 3).coerceAtLeast(0)
        val extraBonus = extraYears * 50.0
        baseSalary + extraBonus
    }
}

val totalBonus: (Employee) -> Double = { employee ->
    // синтаксис буквально повторяет таковой при использовании паттерна Decorator
    extraBonus_A2(baseBonus_A1(calculateSalary(employee))(employee))(employee) 
    // или если переписать все методы в императивном стиле, то визуально скрадывается идея подхода
}
```

Мы отказались от задания иерархии классов в пользу функциональной композиции, которая в свою очередь благодаря синтаксису сохраняет некую преемственность с наследованием: мы накручиваем некоторую функциональность на уже имеющуюся.

Согласен, что для такого простого случая применять наследование избыточно и стоит поискать альтернативы. Но тут хочется задать вопрос: "Как часто создают целую иерархию классов под такую скромную задачу?". Обычно разработчик ограничится утильным классом со статическими методами (в Java) или методами-расширениями (в Kotlin), которые при вынесении в top-level не требуют создания отдельного класса. Стоит ли в таком случае вообще задумываться, что за этими методами могла стоять иерархия классов?

С другой стороны, если логика более замысловатая и требует внедрения зависисмостей, то утильный класс перерастет в сервис. Если логика еще более сложная, то можно говорить об иерархии классов. Это гораздо более значимые части программы, чем просто функции, что несет в себе как большие возможности, так и накладывает ответственность.

Перейдем ко второму примеру. Получаются примерно следующие конструкции:

```kotlin
val k1Translator: (String) -> String = { text -> "[K1] $text" }

val adjustToK2: (String) -> String = { it.replace("K1", "K2-customized") }

val k2Translator = k1Translator andThen adjustToK2
```

Данное решение предлагает плоско модифицировать функциональность, используя композицию оригинальных методов с производными. Здесь опять же все упирается в то, насколько нужно поддерживать единый интерфейс, как сильно меняется базовый код K1 и его результаты. Даже без наследования библиотека K1 может постоянно доставлять хлопоты. Глобально же идея понятна: "Есть возможность обойтись без наследования? Да? Не используй её!". Стоит каждый раз, когда на горизонте появляется ключевое слово extends (или аналоги), прорабатывать альтернативные плоские варианты.