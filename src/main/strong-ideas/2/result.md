Для исследования мной были выбраны микросервисы из рабочего проекта, написанные на языке Java и Kotlin, на базе фреймворка Spring. Опишу специфику выбранных микросервисов:
1) много интеграций с внешними сервисами
2) простые алгоритмы работы, которые преимущественно заключаются в агрегации ответов внешних сервисов

Для организации fuzzing-тестирования была выбрана утилита jazzer https://github.com/CodeIntelligenceTesting/jazzer. Почему обратил внимание на этот проект?
1) подходит для тестирования Java и Kotlin приложений
2) кодовая база активно дорабатывается
3) есть простая интеграция в maven/gradle проект c JUnit 5 (для версий 5.9.+)
4) тестируемый код инструментируется, что положительно сказывается на полноте его покрытия

С какими трудностями я столкнулся при организации fuzzing-тестирования?
1) Логика приложения, основанная преимущественно на взаимодействии с сервисами, тяжело поддается тестированию. Теперь нужно не только мокать вызовы, но и внедрять в их ответы фазз-данные.
2) Тестирование методов с большим числом аргументов или с аргументами с большим числом состояний приводило к OutOfMemoryError. Я не успел разобраться с причиной, связана ли ошибка с несовершенством библиотеки или малым количеством ресурсов.
3) Методы, которые возвращают неразличимые сообщения об ошибке, не могут быть протестированы.
4) Чтобы отличить ожидаемые ошибки от незапланированных, часто требуется написать в тесте длинный список игнорируемых исключительных ситуаций.
5) Выполнение тестов ресурсоемко и может занимать значительное время.

Какие результаты удалось получить?
С помощью fuzzing-тестирования мне не удалось найти ни одной ошибки в исследуемых микросервисах. Как видно, трудности обусловлены спецификой исследуемых проектов. Написание тестов достаточно трудоемко и требует.
В то же время ошибки, сгенерированные в коде мной самостоятельно, благодаря инструментированию были успешно найдены.

Вывод
Fuzzing-тестирование — ресурсоемкий подход к тестированию, который можно эффективно использовать на достаточно узком спектре задач. Какие рекомендации я бы мог дать, если вы все-таки хотите применить его на своем проекте?
1) Вы должны определить точки входа, которые будут подвергаться fuzzing-тестированию. В моем кейсе на первый взгляд хорошей идеей выглядело написание тестов для контроллеров, т.е. тестирование пути от получения запроса микросервисом до передачи ответа наружу. Сделать это достаточно проблематично, так как требует глубокой проработки тестовых сценариев, иначе можно получить низкое покрытие тестируемого кода. Необходимо предварительно изучить приложение и выявить уязвимые места, такие как парсеры данных, работу с сетевыми протоколами или пользовательским вводом, для которых данный подход будет наиболее эффективен.
2) Для сокращения времени разработки тестовых сценариев в части генерации качественных тестовых данных может помочь инструментирование кода (если ваше решение его предоставляет).
3) При изменении контрактов методов в тестируемом коде, которое может происходить неявно (например, новая версия библиотеки начала бросать новое непроверяемое исключение), потребуется правка тестов.