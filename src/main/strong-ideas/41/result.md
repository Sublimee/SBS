2.

Код моих рабочих проектов в этом смысле с течением времени претерпевал изменения, которые могут быть выражены в трех эпохах. В первых двух эпохах оставалось неизменным то, что модели, используемые в интерфейсах сервисов (DTO), располагались в виде java-класса:

1) либо в подключаемой библиотеке. Этот вариант позволяет иметь один источник правды для всей системы.

2) либо локально в коде сервиса. Этот вариант был популярен потому, что при разработке оказывается более удобным иметь модель локально в проекте, а не идти пересобирать библиотеку. Что насчет обратной совместимости? С учетом того, что разработчики следили за обратной совместимостью API, в каждом из проектов могла поддерживаться лишь необходимая ему часть модели. В случае, если обратную совместимость все же нужно было нарушить, приходилось искать все зависимости сервиса с помощью Jaeger :), ведь все перипетии взаимодействия сервисов из документации получить было невозможно.

В первой эпохе для отделения DTO от бизнес-логики использовались мапперы (MapStruct). 

Во второй эпохе было принято (не мной) решение от MapStruct избавляться ввиду, на первый взгляд, боилерплейтности кода: обычно модель данных слоя сервиса 1 к 1 совпадала с моделью слоя контроллера (это отчасти связано со спецификой, которая возложена на наш кластер: предоставлять удобный API, т.е. быть прокси для бэкенда). Если проанализировать код проектов, то можно сказать, что использование DTO стало достаточно хаотичным. Где-то они используются через все слои микросервиса Controller-Service-Repository, а где-то все же вручную мапятся на модели слоя сервисов.

В третьей эпохе появился OpenApi. Ввиду того, что код DTO получаем из спецификаций, использование соответствующих классов не всегда удобно и выглядит несколько странно за пределами контроллеров, поэтому идейно мы смещаемся к первой эпохе, но теперь жестко завязаны на единую спецификацию.

3. 

Подход 1. CQRS

Для нас стал актуальным определенный сценарий? Пусть это будет пример с пользователем и его счетами. Поддержим этот сценарий, создав хранилище, в котором пользователь сразу будет обогащен соответствующей информацией о счетах. Id-шники убрали? Да. Получить пользователя с его счетами просто и по логике и по коду? Да. Сможем создать отдельное хранилище под новый запрос бизнеса? Да. CQRS -- не серебряная пуля, но его применение может значительно упростить обработку ряда сценариев. В некотором смысле материализованные представления могут быть альтернативой CQRS, но со своими особенностями.

Подход 2. Отказ от объединений

Может нам не нужны объединения вовсе? Тогда и ссылки на сущности вовне не понадобятся. Берем NoSQL-решение вроде MongoDB и положим туда пользователя со всеми его счетами. Но, конечно, если модель достаточно сложная, то и одна запись в БД будет достаточно объемной, что потенциально может привести к большой конкуренции.

**Вывод**

Бездумное использование идентификаторов, которое навязано использованием REST API оказывает сильное влияние на проектировании архитектуры приложения и часто приводит к нежелательным последствиям, таким как избыточные зависимости между сервисами, ухудшение производительности и утрата гибкости модели данных. В качестве альтернатив были предложены 2 подхода, которые должны быть рассмотрены.

Однако важно помнить, что оба метода имеют свои ограничения и должны быть применены с учетом особенностей конкретного проекта. CQRS, например, усложняет архитектуру проекта и требует дополнительной работы по синхронизации данных, а использование NoSQL может привести к сложностям с масштабированием и увеличению конкуренции за ресурсы в крупных системах.

Многие проекты прекрасно работают с идентификаторами и ORM. Как было точно подмечено "они делают задачу быстрее за счёт использования стандартных подходов. Но сами вычисления вполне могут стать медленнее, потому что надо постоянно делать дополнительные запросы по указателям (fk на id). Если добавить к этому затраты на ухудшение общего качества и повышение сложности кода, то оказывается, что такой компромисс редко оправдывает себя." Если вы справляетесь с нагрузкой в рамках одного сервера, то, возможно, вам никогда и не придется задуматься о том, что идентификаторы и ORM -- это плохо.