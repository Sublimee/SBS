В рабочем коде был произведен поиск примеров неистинного наследования. В этом я потерпел неудачу, то ли из-за специфики решаемых задач, то ли из-за ограниченного использования наследования разработчиками.  

В качестве исходников были взяты классы java.util.HashMap и java.util.LinkedHashMap, которые были перенесены в [HM.java](..%2F..%2Fjava%2Fstrong%2Fideas%2Flesson_7%2Fbefore%2FHM.java) и LHM[LHM.java](..%2F..%2Fjava%2Fstrong%2Fideas%2Flesson_7%2Fbefore%2FLHM.java) соответственно. В исходном классе LinkedHashMap переопределяется метод valuesToArray класса HashMap. Заменим эту конструкцию на вызов посетителя. Коммит: 

Отмечу плюсы и минусы, которые вытекают из получившегося решения. 

**Плюсы**

Иерархия реализаций ранее переопределяемых методов вынесена в отдельный класс и не потребует в дальнейшем модификации посещаемых классов.

**Минусы**

* Исходные классы знают о существовании посетителя. Посетителя нужно как-то передавать в методы: или при вызове, или он должен задаваться, например, в конструкторе. 

* Логика класса размазывается по программе.

* Чтобы посетитель мог выполнить свои функции, может потребоваться доступ к приватным членам класса.

* Для каждой новой операции или действия потребуется создавать нового посетителя, что может стать проблемой при большом количестве операций.

**Вывод**

Паттерн Visitor полезен в определенных сценариях, когда необходимо отделить операции от объектов, над которыми они выполняются (не наш случай), но его следует использовать с осторожностью, учитывая потенциальные проблемы с изменением структуры и нарушением инкапсуляции.