## 1. Избавляться от точек генерации исключений

### 1.1.

Я спроектировал REST API таким образом, что первым запросом всегда должен был быть запрос наличия у пользователя повышенного кэшбэка. После получения положительного ответа могли следовать другие запросы (получение программы повышенного кэшбэка и др.). Как пользователи API используют интерфейс? Правильно! Делают сразу целевой запрос, обрабатывая ошибку в случае, если повышенный кэшбэк недоступен. Каждый такой вызов фиксируется в логах, в связи с чем по внешним признакам можно судить о том, что сервис работает некорректно. Как решить эту проблему? Добавить в каждый ответ флаг наличия у пользователя повышенного кэшбэка. В случае, если повышенный кэшбэк доступен, то ответ будет выглядеть таким образом: 

```
{ 
    "isPromotedCashbackAvailable": true,
    "business_data": ...
}
```

иначе:

```
{
    "isPromotedCashbackAvailable": false
}
```

Такая доработка позволит избавиться от точки генерации исключений, которая заключается в правильной последовательности вызовов методов API.

### 1.2.

В том же REST API у меня есть две ручки: первая отвечает за получение информации для розыгрыша, а вторая -- за получение информации о победителе розыгрыша. Если вызвать первую ручку, когда розыгрыш уже прошел, то вылетит исключение. И наоборот, если вызвать вторую ручку, когда розыгрыш еще не прошел, то вылетит исключение. Логично выглядит добавить по флагу в каждый ответ, который будет отражать состояние розыгрыша (состоялся или нет). В таком случае ответы ручки получения информации для розыгрыша будут выглядеть следующим образом:   

```
{ 
    "isWinnerConfirmed": false,
    "business_data": ...
}
```

и 

```
{ 
    "isWinnerConfirmed": true
}
```

А ответы ручки для получения информации о победителе розыгрыша будут выглядеть следующим образом:

```
{ 
    "isWinnerConfirmed": false
}
```

и

```
{ 
    "isWinnerConfirmed": true,
    "business_data": ...
}
```

## 2. Отказаться от дефолтных конструкторов без параметров

### 2.1.

У нас есть класс для кнопок:

```
data class Button(
    val title: String,
    val deeplink: String? = null,
    val clickLink: String? = null,
    val documentUrl: String? = null,
    val alertMessage: String? = null,
)
```

Его проблема в том, что у него два предназначения: использование на сайте для перехода по ссылке и переход на скачивание документа в мобильном приложении. Нужно разделить класс таким образом, чтобы каждый вновь созданный экземпляр конструировался целиком:

```
abstract class Button(
    title: String,
)

data class СlickButton(
    val title: String,
    val deeplink: String,
    val alertMessage: String,
) : Button(title)

data class AboutButton(
    val title: String,
    val documentUrl: String,
) : Button(title)
```

Теперь, когда все параметры конструкторов обязательны, можно говорить не только о правильном конструировании объекта, но и о том, что классы теперь ясно отражают свое предназначение, лучше моделируя сущности интерфейса.

### 2.2.

Аналогично дела обстоят и с иконками:

```
data class Icon(
    val imageUrl: String? = null,
    val iconPackLink: String? = null,
    val color: String? = null,
)
```

Универсальный класс, который использовался для двух целей можно разделить на два специализированных:

```
interface Icon

data class IconFromUrl(
    val imageUrl: String,
) : Icon

data class IconFromPack(
    val iconPackLink: String,
    val color: String,
) : Icon
```

## 3. Избегать увлечения примитивными типами данных

### 3.1.

В сервисе, который занимается анализом версий подключенных зависимостей я нашел такой метод:

```
data class DependencyUpdaterVerificationItem(
    ...
        val latestVersion: String,
    ...
)
```

Что можно сказать о версии приложения, записанной в виде строки? Тяжело понять формат записи версии, а также непонятно, как сравнить две версии даже зная формат? Напрашивается создание отдельного класса:

```
public class Version implements Comparable<Version> {

    public static final String DELIMITER = ".";
    
    private Integer major;
    private Integer minor;
    private Integer patch;
    private Integer buildNumber;

    @Override
    public int compareTo(Version otherVersion) {
    ...
```

Какие проблемы сразу решаются?
1) более точно моделируем сущность вокруг которой работает сервис, что упрощает чтение, написание и сопровождение кода
2) инкапсуляция логики сравнения

### 3.2.

В одном из сервисов нашел такой метод:

```
public Integer getTimeout(String name) {
    return delegate.getTimeout(name);
}
```

Он не совсем про смысловой уровень моделирования предметной области, но тоже интересен, так как создает большую когнитивную нагрузку. Сейчас из кода программы совершенно невозможно понять, какие единицы измерения времени предполагаются. Решение проблемы достаточно просто:

```
public class Timeout {
    private final long value;
    private final TimeUnit unit;
    ...
```

Будем хранить не только само значение, но и единицы измерения.

То же можно сказать и про баланс, который в программе зачастую должен неразрывно следовать с валютой и минорными единицами.

## Вывод

Я давно перестал винить себя за ошибки, которые продиктованы плохим дизайном (если только я не являюсь его автором). Если система спроектирована так, что она допускает появление ошибок, то они обязательно будут появляться по самым разным причинам: невнимательность, поверхностное изучение документации, невозможность уложить в голове все взаимосвязи и т.д.
Поэтому всеми силами пытаемся избавиться от ошибок так, чтобы это просто не позволял дизайн: 
* если конструируем объект, то только целиком, 
* если выбрасываем ошибку, то она должна свидетельствовать о реальном сбое, 
* если моделируем предметную область, то отходим от простых типов, наподобие строки или целого числа, а используем вполне конкретные классы
* и т.д.