**1. Это не баг**

В одном из проектов был неиспользуемый (нет вызовов) участок кода, на который ругался статический анализатор. Удаление этого участка кода приводило к невозможности старта программы. Такой участок кода необходимо хотя бы снабдить соответствующим комментарием или разобраться в причине такого поведения (вероятно, привносимое сторонней библиотекой).

При старте десктопного Electron приложения, которое состояло из UI и бэкенда с базой данных, требовалось добавить задержку на инициализацию UI, чтобы БД успела проинициализироваться. Это было рабочее, но несколько наивное решение, которое должно было быть заменено на периодические попытки соединения с заданным таймаутом.

**2. Это не баг (а что-то другое)**

При обращении к сервису бэкенда используется кэш. Если отправить 2 одинаковых параллельных запроса, то на бэк уйдет оба из них. Второй отправленный запрос должен встать в очередь, ожидая результат, полученный первым запросом, чтобы не генерировать избыточную нагрузку.

В сервисе есть 2 эндпоинта: один отвечает за определение доступности виджета, а второй -- за получение виджета. Логика этих эндпоинтов переиспользует один и тот же участок кода, который выполняет обращение к сторонним сервисам. Проблема в том, что обращений к сторонним сервисам в первом эндпоинте можно избежать, но они все равно выполняются. С ростом нагрузки на первый эндпоинт, когда по сценарию нет необходимости вызывать второй эндпоинт, появляется паразитная нагрузка на сторонние сервисы.

**3. Это сбивает людей с толку**

Из кода были удалены вызовы сервиса. Но в тестах и в конфигурации упоминания сервиса остались. Это не мешают работе программы, но сбивают с толку разработчиков, которые будут пытаться найти эти вызовы в коде программы.

Программа использует библиотеку для реактивного программирования Reactor. В методе использовался вызов стороннего сервиса и Flux (представляет поток от 0 до N элементов). После рефакторинга вызов стороннего сервиса из метода был удален, но использование Flux осталось, хотя внутри метода можно было работать просто с коллекцией элементов.

**4. Это хрупкость**

При работе с внешним API по каждому пользователю присылается набор его партнерских офферов с полным описанием каждого из них. Сначала, пока нагрузка на сервис была небольшой (маленький rps), видимых проблем не было. Но с ростом нагрузки значительно повышается нагрузка на сеть.

Работа с суммами в рамках Integer, а не Long, так как в финансовом приложении мы оперировали небольшими суммами. Это могло стать потенциальной проблемой при переполнении.

**5. Не соответствует требованиям OSHA**

Я пришел на курсы, где для получения практического опыта командой выпускников разрабатывалась CRM. В целом проект работал, но модель данных была отображена в БД ужасно запутанным и нелогичным образом. Это было изначально некорректно заложенное решение. Каждая задача, которую я делал, упиралась в проблемы с данными в БД. Меня хватило на месяц такой разработки.

Моя команда писала инструмент для формирования отчетности в формате XBRL. В проекте было мало тестов, а код был запутанным и практически неподдерживаемым. Почему? Каждая небольшая доработка часто приводила к выходу из строя старой функциональности.


**Вывод**

Индустрия привыкла, что самое страшное, что есть в ПО -- это баг. Причем под багом очень часто подразумевается банально некорректный ответ системы на запрос с заданными входными параметрами. Это что-то, что сразу бросается в глаза, что-то банальное, что всегда на виду. Бизнес уже привык, что баг можно полечить быстрым хотфиксом, который решит все проблемы. А разработчики только и рады стараться.

Кажется, что слово "баг" настолько замарано некомпетентностью разработчиков и менеджеров, что его надо заменить другим словом -- "проблема". Баг можно быстро пофиксить, а вот проблему уже надо решать. Проблема производительности, проблема алгоритма, проблема архитектуры -- это уже звучит солидно. Проблема -- нечто комплексное, что требует внимания и ресурсов. Баг -- быстрофикс на пару строк и в продакшен.

Приведенные примеры подчеркивают, что разработка качественного программного обеспечения требует более чем просто написания кода без ошибок. Она требует внимательного подхода к аналитике, архитектуре, понимания контекста применения, а также способности предвидеть и управлять будущими изменениями и масштабированием. Все эти аспекты необходимы для создания устойчивого, эффективного и легко поддерживаемого программного продукта без багов)