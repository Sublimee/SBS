В своем коде мне не удалось найти примеры классов, экземпляры которых переходят по состояниям при вызовах соответствующих методов. Это связано со спецификой разрабатываемых сервисов: они относятся к middle-слою, то есть выполняют преимущественно роль proxy между глубоким банковским бэкендом (где как раз и хранятся состояния) и клиентами (преимущественно пользователи мобильных приложений).

Что я рассматривал в качестве потенциальных кандидатов? Рассмотрим следующий класс.

```kotlin
data class ProgramWidget(
    val id: Int,
    ...
    val confirmed: Boolean,
    ...
)
```

Нужно ли разделять ProgramWidget на 2 класса, которые будут отвечать за программы кэшбэка с подтвержденным и неподтвержденным выбором пользователя? Изменение состояния по соответствующей программе происходит на стороне бэкенда (отражается в БД), мы лишь дергаем соответствующие ручки его API. Непосредственно изменения состояния (в БД) нами может быть зафиксировано только при очередном получении соответствующего экземпляра. Из этого описания как раз видна суть middle-слоя, который скорее помогает более удобно работать нашим клиентам с API.

В этом кейсе, кажется, что наличие небольшого числа состояний и отсутствие непосредственно переходов по состояниям на нашей стороне не являются причиной проведения озвученного ранее рефакторинга.

То же самое касается и бонусных счетов, состояния которых отображаются в объекты enum'а:

```kotlin
enum class Status(
    val value: Int,
) {
    NEW(1), ACTIVE(2), FROZEN(3), BLOCKED(4), CLOSED(5);
}
```

Необходимость лишь отображения статуса и отсутствие в коде на нашей стороне необходимости перехода объекта между состояниями говорят об нецелесообразности введения переходов между состояниями. В таком случае рассмотрим некоторые конкретные реализации, которые могут позволить избежать проблемы произвольного вызова методов в дополнение к тем, что уже были упомянуты.

В самом простом случае, когда переходы от состояния к состоянию достаточно простые и число полей небольшое можно рассмотреть использование паттерна Строитель. Будем использовать но не наращивание объекта билдера, а переходы в рамках группы классов:

```kotlin
fun main(args: Array<String>) {
    val doc = NewDocument()
        .setTitle("Мой документ")
        .addContent("Это пример содержимого.")
        .finalizeDocument()
    doc.printDocument()
}

// Состояние 1: Новый документ
class NewDocument {
    fun setTitle(title: String): TitledDocument {
        return TitledDocument(title)
    }
}

// Состояние 2: Документ с заголовком
class TitledDocument(private val title: String) {
    fun addContent(content: String): DocumentWithContent {
        return DocumentWithContent(title, content)
    }
}

// Состояние 3: Документ с содержимым
class DocumentWithContent(private val title: String, private val content: String) {
    fun finalizeDocument(): FinalizedDocument {
        return FinalizedDocument(title, content)
    }
}

// Состояние 4: Готовый к печати документ
class FinalizedDocument(private val title: String, private val content: String) {
    fun printDocument() {
        ...
    }
}
```

В целом, если идет только наращивание функциональности, то можно использовать наследование с расширением, однако, кажется, что по контексту это не всегда может быть корректно.

Если очередной переход требует выполнения нескольких операций или установки нескольких полей, то потребуется введение синтетических методов:

```kotlin
class MainComponentsBuilder(private val motherboard: String) {
    private var cpu: String? = null
    private var ram: String? = null

    fun installCpu(cpu: String): MainComponentsBuilder {
        this.cpu = cpu
        return this
    }

    fun installRam(ram: String): MainComponentsBuilder {
        this.ram = ram
        return this
    }

    // Проверка, что все необходимые параметры установлены, прежде чем перейти к следующему этапу
    fun next(): OptionalComponentsBuilder {
        if (cpu == null || ram == null) {
            throw IllegalStateException("Не все основные составляющие процессора установлены")
        }
        validatePostCodes()
        return OptionalComponentsBuilder(motherboard, "$cpu, $ram")
    }
    
    ...
}
```

Если список параметров большой, то можно перейти к такому варианту:

```kotlin
class ComputerParams(
    var motherboard: String? = null,
    var cpu: String? = null,
    var ram: String? = null,
    var optionalComponents: List<OptionalComponent>? = null,
)

class MainComponentsBuilder(params: ComputerParams) {
    fun installCpu(cpu: String) = apply { params.cpu = cpu }
    fun installRam(ram: String) = apply { params.ram = ram }
    fun next(): OptionalComponentsBuilder = OptionalComponentsBuilder(params)
}
```

В качестве более серьезной альтернативы можно рассмотреть Spring State Machine (https://habr.com/ru/articles/462371/), которая позволяет достаточно элегантно работать с состояниями.

Что если нам нужно проверить корректность уже написанной программы? Если у нас нет возможности ввести контролируемые состояния с помощью рефакторинга или состояния используются где-то внутри библиотек, то можно сравнивать предварительно разработанные спецификации программных библиотек с трассами выполнения инструментированной программы. Как это работает можно прочитать в моей работе https://seim-conf.org/media/materials/2018/proceedings/SEIM-2018_Short_Papers.pdf на страницах 53-61.

Если мы хотим выйти за границы управления состояниями внутри приложения, то стоит рассмотреть такой инструмент, как Camunda (Zeebe). Camunda предназначена для моделирования, автоматизации, выполнения и мониторинга бизнес-процессов в рамках организации. Ее особенностью является поддержка стандартов BPMN.

Вывод

Современные библиотеки, REST API и даже обычный бизнесовый код достаточны сложны. Работа с ними зачастую становится нетривиальной задачей. Обратимся к одной из причин наличия этой сложности.

 Несмотря на то, что одна из самых популярных парадигм (ООП) подразумевает наличие объектов, которые должны взаимодействовать друг с другом, поддержка состояний в ООП-языках развита достаточно слабо и практически не встречалась мне в проектах (отчасти из-за отсутствия поддержки TOP в Java). Если программа подразумевает наличие состояний и набор действий, которые не ограничены этими состояниями, то мы собственноручно вносим возможность ошибок.

Как видим, паттерны State и State Machine подходят для управления состояниями и переходами в рамках одного приложения, но не отличаются элегантностью получающегося исходного кода.

Найденные мной инструменты https://arxiv.org/pdf/1904.01286.pdf и https://github.com/jdmota/java-typestate-checker требуют описания протоколов, что зачастую также не воспринимается разработчиками положительно.

Я уже рассказывал, как нарушение порядка вызовов в разработанном мной REST API привело к тому, что клиенты хотя и получали функциональность, но делали систему неподдерживаемой с точки зрения observability: множество ошибок в логах при отсутствии реальных бизнесовых ошибок не давали возможность увидеть реальные проблемы сервиса. Слабая попытка в виде указания действий в HATEOAS не спасет от настойчивого пользователя.

Существующие подходы к решению проблемы работы с состояниями и переходами распространены слабо. Как и любой подход он должен стать безусловно удобным и простым к использованию. Чаще всего такой эффект достигается при интеграции функциональности в популярные IDE.