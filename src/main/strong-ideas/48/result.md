# Пример 1

Во всем кластере заменили Hazelcast (Java) на Redis (C). Исходной причиной было снижение оверхеда потребляемой JVM памяти для малых по объему кэшей микросервисов (JVM могла есть больше, чем объем кэша в десятки раз). В дополнение к этому мы получили возможность достаточно просто разработать новую функциональность на основе Redis, а именно распределенную (кластерную) блокировку и очереди.

# Пример 2

В одном из проектов заменил PostgreSQL на MongoDB. Исходной причиной стало понимание того, что более эффективно будет работать с денормализованными данными. Таким образом мы перешли от набора таблиц к единому документу, что упростило схему БД и сделало выполнение запросов более быстрым. В дополнение к этому мы получили отказоустойчивый кластер из коробки, что упрощает процесс его сопровождения.

# Пример 3

Выполнили переезд из кластера Mesos в кластер k8s. Исходной причиной было желание следовать мировым стандартам оркестрации приложений. Сам переезд длился достаточно долго по причине того, что мы сразу воспользовались возможностями, которые предоставляли нам "бесплатные горизонты", а именно использовали плагин Istio для того, чтобы сделать транспорт в кластере более безопасным (что по моей практике обычно усложняет любую систему чуть ли не на порядок). "Бесплатные горизонты" также включают в себя возможность использовать другие готовые плагины и писать собственные.

# Пример 4

Некоторые сервисы в нашем кластере я переводил с Java на Kotlin. Исходной причиной было скрыть сложности написания/поддержки реактивных цепочек Webflux за корутинами. После миграции логика сервиса осталась прежней, внешние контракты не изменились — то есть, система сохранила статус-кво. В дополнение мы получили несколько "бесплатных" возможностей:

* благодаря data-классам и null-safety снизилось число уязвимых от NPE мест и упростились модели;

* стало проще писать тесты и вспомогательные утилиты благодаря extension-функциям.

# Пример 5

Один из сервисов в нашем кластере я экспериментально переводил с Kotlin + WebFlux на Kotlin + Virtual Threads + Spring Web. Исходной причиной был отказ от Webflux, так как мы не используем его фичи кроме как написание асинхронных реактивных неблокирующих цепочек вызовов (которые в Kotlin скрыты за корутиными). Сам Webflux привносит сложности в отладке и разработке библиотек (стартеров). Сама миграция заключалась в поднятии версии Java, замене некоторых библиотек и интерфейсов. Теперь нет необходимости выводить блокирующие операции на отдельный пул потоков, работать с буферами Netty и реактивными контекстами. Предварительно будем мигрировать на этот стек во всех сервисах. В качестве "бесплатных горизонтов" мы получим упрощение кодовой и поддержки базы стартеров.

# Вывод

Какие два выбора у нас есть?

* удобства (в некотором смысле простота)

* возможности

Есть технологии-конкуренты, например PostgreSQL и MongoDB. Выбор технологии здесь зависит от решаемой задачи и нашего взгляда на эту задачу. Однако зачастую индустрия уже сделала за нас выбор. Каким образом? Мне кажется, что общая тенденция в IT -- это устаканивание. Технологии стали реально удобными, в том числе за счет высокого уровня стандартизации.

Например, для мониторинга повсеместно используется стандарт Prometheus + Grafana. Почему?

* удобно (одобрено многими проектами)

* гибко (расширяемость)

ITшечка прошла достаточно итераций, чтобы начать делать такие продукты. Даже сложно провести грань между "удобно" и "гибко", где начинается и заканчивается каждый из них. Уж больно тесно они переплетены.

Да, появляются новые решения, например VictoriaMetrics, причем обычно с прицелом легкой на них миграции. Это подтвердил и наш опыт.

Сейчас OpenTelemetry обретает популярность. Он опирается на те же принципы. Поэтому и Go так популярен).

Получается, что важно быть в теме последних нововведений, чтобы делать свои проекты простыми, удобными, поддерживаемыми. Но в то же время не стоит кидаться обновлять стек на любой чих. Важно трезво оценивать эффект от вложенных усилий.